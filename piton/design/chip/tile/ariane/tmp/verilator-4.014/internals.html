<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#INTRODUCTION">INTRODUCTION</a></li>
  <li><a href="#CODE-FLOWS">CODE FLOWS</a>
    <ul>
      <li><a href="#Verilator-Flow">Verilator Flow</a></li>
      <li><a href="#Key-Classes-Used-in-the-Verilator-Flow">Key Classes Used in the Verilator Flow</a></li>
      <li><a href="#Multithreaded-Mode">Multithreaded Mode</a>
        <ul>
          <li><a href="#Partitioning">Partitioning</a></li>
          <li><a href="#Estimating-Logic-Costs">Estimating Logic Costs</a></li>
          <li><a href="#Scheduling-Macro-Tasks-at-Runtime">Scheduling Macro-Tasks at Runtime</a></li>
          <li><a href="#Locating-Variables-for-Best-Spatial-Locality">Locating Variables for Best Spatial Locality</a></li>
          <li><a href="#Improving-Multithreaded-Performance-Further-a-TODO-list">Improving Multithreaded Performance Further (a TODO list)</a></li>
        </ul>
      </li>
      <li><a href="#Verilated-Flow">Verilated Flow</a></li>
    </ul>
  </li>
  <li><a href="#CODING-CONVENTIONS">CODING CONVENTIONS</a>
    <ul>
      <li><a href="#Indentation-style">Indentation style</a></li>
      <li><a href="#The-astgen-script">The astgen script</a></li>
      <li><a href="#Visitor-Functions">Visitor Functions</a></li>
      <li><a href="#Iterators">Iterators</a>
        <ul>
          <li><a href="#Caution-on-Using-Iterators-When-Child-Changes">Caution on Using Iterators When Child Changes</a></li>
        </ul>
      </li>
      <li><a href="#Identifying-derived-classes">Identifying derived classes</a></li>
    </ul>
  </li>
  <li><a href="#TESTING">TESTING</a>
    <ul>
      <li><a href="#Preparing-to-Run-Tests">Preparing to Run Tests</a></li>
      <li><a href="#Controlling-the-Test-Driver">Controlling the Test Driver</a></li>
      <li><a href="#Regression-Testing-for-Developers">Regression Testing for Developers</a></li>
    </ul>
  </li>
  <li><a href="#DEBUGGING">DEBUGGING</a>
    <ul>
      <li><a href="#debug">--debug</a></li>
      <li><a href="#dot-output">.dot output</a></li>
      <li><a href="#tree-output">.tree output</a></li>
      <li><a href="#Debugging-with-GDB">Debugging with GDB</a></li>
    </ul>
  </li>
  <li><a href="#ADDING-A-NEW-FEATURE">ADDING A NEW FEATURE</a>
    <ul>
      <li><a href="#Adding-a-new-pass">Adding a new pass</a></li>
    </ul>
  </li>
  <li><a href="#DISTRIBUTION">DISTRIBUTION</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Verilator Internals</p>

<h1 id="INTRODUCTION">INTRODUCTION</h1>

<p>This file discusses internal and programming details for Verilator. It&#39;s the first for reference for developers and debugging problems.</p>

<p>See also the Verilator internals presentation at http://www.veripool.org.</p>

<h1 id="CODE-FLOWS">CODE FLOWS</h1>

<h2 id="Verilator-Flow">Verilator Flow</h2>

<p>The main flow of Verilator can be followed by reading the Verilator.cpp process() function:</p>

<p>First, the files specified on the command line are read. Reading involves preprocessing, then lexical analysis with Flex and parsing with Bison. This produces an abstract syntax tree (AST) representation of the design, which is what is visible in the .tree files described below.</p>

<p>Verilator then makes a series of passes over the AST, progressively refining and optimizing it.</p>

<p>Cells in the AST first linked, which will read and parse additional files as above.</p>

<p>Functions, variable and other references are linked to their definitions.</p>

<p>Parameters are resolved and the design is elaborated.</p>

<p>Verilator then performs many additional edits and optimizations on the hierarchical design. This includes coverage, assertions, X elimination, inlining, constant propagation, and dead code elimination.</p>

<p>References in the design are then pseudo-flattened. Each module&#39;s variables and functions get &quot;Scope&quot; references. A scope reference is an occurrence of that un-flattened variable in the flattened hierarchy. A module that occurs only once in the hierarchy will have a single scope and single VarScope for each variable. A module that occurs twice will have a scope for each occurrence, and two VarScopes for each variable. This allows optimizations to proceed across the flattened design, while still preserving the hierarchy.</p>

<p>Additional edits and optimizations proceed on the pseudo-flat design. These include module references, function inlining, loop unrolling, variable lifetime analysis, lookup table creation, always splitting, and logic gate simplifications (pushing inverters, etc).</p>

<p>Verilator orders the code. Best case, this results in a single &quot;eval&quot; function which has all always statements flowing from top to bottom with no loops.</p>

<p>Verilator mostly removes the flattening, so that code may be shared between multiple invocations of the same module. It localizes variables, combines identical functions, expands macros to C primitives, adds branch prediction hints, and performs additional constant propagation.</p>

<p>Verilator finally writes the C++ modules.</p>

<h2 id="Key-Classes-Used-in-the-Verilator-Flow">Key Classes Used in the Verilator Flow</h2>

<dl>

<dt id="AstNode"><code>AstNode</code></dt>
<dd>

<p>The AST is represented at the top level by the class <code>AstNode</code>. This abstract class has derived classes for the individual components (e.g. <code>AstGenerate</code> for a generate block) or groups of components (e.g. <code>AstNodeFTask</code> for functions and tasks, which in turn has <code>AstFunc</code> and <code>AstTask</code> as derived classes).</p>

<p>Each <code>AstNode</code> has pointers to up to four children, accessed by the <code>op1p</code> through <code>op4p</code> methods. These methods are then abstracted in a specific Ast* node class to a more specific name. For example with the <code>AstIf</code> node (for <code>if</code> statements), <code>ifsp</code> calls <code>op2p</code> to give the pointer to the AST for the &quot;then&quot; block, while <code>elsesp</code> calls <code>op3p</code> to give the pointer to the AST for the &quot;else&quot; block, or NULL if there is not one.</p>

<p><code>AstNode</code> has the concept of a next and previous AST - for example the next and previous statements in a block. Pointers to the AST for these statements (if they exist) can be obtained using the <code>back</code> and <code>next</code> methods.</p>

<p>It is useful to remember that the derived class <code>AstNetlist</code> is at the top of the tree, so checking for this class is the standard way to see if you are at the top of the tree.</p>

<p>By convention, each function/method uses the variable <code>nodep</code> as a pointer to the <code>AstNode</code> currently being processed.</p>

</dd>
<dt id="AstNVisitor"><code>AstNVisitor</code></dt>
<dd>

<p>The passes are implemented by AST visitor classes (see <a href="#Visitor-Functions">&quot;Visitor Functions&quot;</a>). These are implemented by subclasses of the abstract class, <code>AstNVisitor</code>. Each pass creates an instance of the visitor class, which in turn implements a method to perform the pass.</p>

</dd>
<dt id="V3Graph"><code>V3Graph</code></dt>
<dd>

<p>A number of passes use graph algorithms, and the class <code>V3Graph</code> is provided to represent those graphs. Graphs are directed, and algorithms are provided to manipulate the graphs and to output them in <i>GraphViz</i> dot format (see <a href="http://www.graphviz.org/">http://www.graphviz.org/</a>). <code>V3Graph.h</code> provides documentation of this class.</p>

</dd>
<dt id="V3GraphVertex"><code>V3GraphVertex</code></dt>
<dd>

<p>This is the base class for vertices in a graph. Vertices have an associated <code>fanout</code>, <code>color</code> and <code>rank</code>, which may be used in algorithms for ordering the graph. A generic <code>user</code>/<code>userp</code> member variable is also provided.</p>

<p>Virtual methods are provided to specify the name, color, shape and style to be used in dot output. Typically users provide derived classes from <code>V3GraphVertex</code> which will reimplement these methods.</p>

<p>Iterators are provided to access in and out edges. Typically these are used in the form:</p>

<pre><code>    for (V3GraphEdge *edgep = vertexp-&gt;inBeginp();
         edgep;
         edgep = edgep-&gt;inNextp()) {</code></pre>

</dd>
<dt id="V3GraphEdge"><code>V3GraphEdge</code></dt>
<dd>

<p>This is the base class for directed edges between pairs of vertices. Edges have an associated <code>weight</code> and may also be made <code>cutable</code>. A generic <code>user</code>/<code>userp</code> member variable is also provided.</p>

<p>Accessors, <code>fromp</code> and <code>top</code> return the &quot;from&quot; and &quot;to&quot; vertices respectively.</p>

<p>Virtual methods are provided to specify the label, color and style to be used in dot output. Typically users provided derived classes from <code>V3GraphEdge</code> which will reimplement these methods.</p>

</dd>
<dt id="V3GraphAlg"><code>V3GraphAlg</code></dt>
<dd>

<p>This is the base class for graph algorithms. It implements a <code>bool</code> method, <code>followEdge</code> which algorithms can use to decide whether an edge is followed. This method returns true if the graph edge has weight greater than one and a user function, <code>edgeFuncp</code> (supplied in the constructor) returns <code>true</code>.</p>

<p>A number of predefined derived algorithm classes and access methods are provided and documented in <code>V3GraphAlg.cpp</code>.</p>

</dd>
</dl>

<h2 id="Multithreaded-Mode">Multithreaded Mode</h2>

<p>In --threads mode, the frontend of the Verilator pipeline is the same as serial mode, up until V3Order.</p>

<p>V3Order builds a fine-grained, statement-level dependency graph that governs the ordering of code within a single eval() call. In serial mode, that dependency graph is used to order all statements into a total serial order. In parallel mode, the same dependency graph is the starting point for a partitioner (V3Partition).</p>

<p>The partitioner&#39;s goal is to coarsen the fine-grained DAG into a coarser DAG, while maintaining as much available parallelism as possible. Often the partitioner can transform an input graph with millions of nodes into a coarsened execution graph with a few dozen nodes, while maintaining enough parallelism to take advantage of a modern multicore CPU. Runtime synchronization cost is not prohibitive with so few nodes.</p>

<h3 id="Partitioning">Partitioning</h3>

<p>Our partitioner is similar to the one Vivek Sarkar described in his 1989 paper &quot;Partitioning and Scheduling Parallel Programs for Multiprocessors&quot;.</p>

<p>Let&#39;s define some terms:</p>

<dl>

<dt id="Par-Factor"><code>Par Factor</code></dt>
<dd>

<p>The available parallelism or &quot;par-factor&quot; of a DAG is the total cost to execute all nodes, divided by the cost to execute the longest critical path through the graph. This is the speedup you would get from running the graph in parallel, if given infinite CPU cores available and communication and synchronization are zero.</p>

</dd>
<dt id="Macro-Task"><code>Macro Task</code></dt>
<dd>

<p>When the partitioner coarsens the graph, it combines nodes together. Each fine-grained node represents an atomic &quot;task&quot;; combined nodes in the coarsened graph are &quot;macro-tasks&quot;. This term comes from Sarkar. Each macro-task executes from start to end on one processor, without any synchronization to any other macro-task during its execution. (Synchronization only happens before the macro-task begins or after it ends.)</p>

</dd>
<dt id="Edge-Contraction"><code>Edge Contraction</code></dt>
<dd>

<p>Our partitioner, like Sarkar&#39;s, primarily relies on &quot;edge contraction&quot; to coarsen the graph. It starts with one macro-task per atomic task and iteratively combines pairs of edge-connected macro-tasks.</p>

</dd>
<dt id="Local-Critical-Path"><code>Local Critical Path</code></dt>
<dd>

<p>Each node in the graph has a &quot;local&quot; critical path. That&#39;s the critical path from the start of the graph to the start of the node, plus the node&#39;s cost, plus the critical path from the end of the node to the end of the graph.</p>

</dd>
</dl>

<p>Sarkar calls out an important trade-off: coarsening the graph reduces runtime synchronization overhead among the macro-tasks, but it tends to increase the critical path through the graph and thus reduces par-factor.</p>

<p>Sarkar&#39;s partitioner, and ours, chooses pairs of macro-tasks to merge such that the growth in critical path is minimized. Each candidate merge would result in a new node, which would have some local critical path. We choose the candidate that would produce the shortest local critical path. Repeat until par-factor falls to a target threshold. It&#39;s a greedy algorithm, and it&#39;s not guaranteed to produce the best partition (which Sarkar proves is NP-hard).</p>

<h3 id="Estimating-Logic-Costs">Estimating Logic Costs</h3>

<p>To compute the cost of any given path through the graph, Verilator estimates an execution cost for each task. Each macro-task has an execution cost which is simply the sum of its tasks&#39; costs. We assume that communication overhead and synchronization overhead are zero, so the cost of any given path through the graph is simply the sum of macro-task execution costs. Sarkar does almost the same thing, except that he has nonzero estimates for synchronization costs.</p>

<p>Verilator&#39;s cost estimates are assigned by the InstrCountCostVisitor. This class is perhaps the most fragile piece of the multithread implementation. It&#39;s easy to have a bug where you count something cheap (eg. accessing one element of a huge array) as if it were expensive (eg. by counting it as if it were an access to the entire array.) Even without such gross bugs, the estimates this produce are only loosely predictive of actual runtime cost. Multithread performance would be better with better runtime costs estimates. This is an area to improve.</p>

<h3 id="Scheduling-Macro-Tasks-at-Runtime">Scheduling Macro-Tasks at Runtime</h3>

<p>After coarsening the graph, we must schedule the macro-tasks for runtime. Sarkar describes two options: you can dynamically schedule tasks at runtime, with a runtime graph follower. Sarkar calls this the &quot;macro-dataflow model.&quot; Verilator does not support this; early experiments with this approach had poor performance.</p>

<p>The other option is to statically assign macro-tasks to threads, with each thread running its macro-tasks in a static order. Sarkar describes this in Chapter 5. Verilator takes this static approach. The only dynamic aspect is that each macro task may block before starting, to wait until its prerequisites on other threads have finished.</p>

<p>The synchronization cost is cheap if the prereqs are done. If they&#39;re not, fragmentation (idle CPU cores waiting) is possible. This is the major source of overhead in this approach. The --prof-threads switch and the <code>verilator_gantt</code> script can visualize the time lost to such fragmentation.</p>

<h3 id="Locating-Variables-for-Best-Spatial-Locality">Locating Variables for Best Spatial Locality</h3>

<p>After scheduling all code, we attempt to locate variables in memory such that variables accessed by a single macro-task are close together in memory. This provides &quot;spatial locality&quot; -- when we pull in a 64-byte cache line to access a 2-byte variable, we want the other 62 bytes to be ones we&#39;ll also likely access soon, for best cache performance.</p>

<p>This turns out to be critical for performance. It should allow Verilator to scale to very large models. We don&#39;t rely on our working set fitting in any CPU cache; instead we essentially &quot;stream&quot; data into caches from memory. It&#39;s not literally streaming, where the address increases monotonically, but it should have similar performance characteristics, so long as each macro-task&#39;s dataset fits in one core&#39;s local caches.</p>

<p>To achieve spatial locality, we tag each variable with the set of macro-tasks that access it. Let&#39;s call this set the &quot;footprint&quot; of that variable. The variables in a given module have a set of footprints. We can order those footprints to minimize the distance between them (distance is the number of macro-tasks that are different across any two footprints) and then emit all variables into the struct in ordered-footprint order.</p>

<p>The footprint ordering is literally the traveling salesman problem, and we use a TSP-approximation algorithm to get close to an optimal sort.</p>

<p>This is an old idea. Simulators designed at DEC in the early 1990s used similar techniques to optimize both single-thread and multi-thread modes. (Verilator does not optimize variable placement for spatial locality in serial mode; that is a possible area for improvement.)</p>

<h3 id="Improving-Multithreaded-Performance-Further-a-TODO-list">Improving Multithreaded Performance Further (a TODO list)</h3>

<dl>

<dt id="Wave-Scheduling"><code>Wave Scheduling</code></dt>
<dd>

<p>To allow the verilated model to run in parallel with the testbench, it might be nice to support &quot;wave&quot; scheduling, in which work on a cycle begins before eval() is called or continues after eval() returns. For now all work on a cycle happens during the eval() call, leaving Verilator&#39;s threads idle while the testbench (everything outside eval()) is working. This would involve fundamental changes within the partitioner, however, it&#39;s probably the best bet for hiding testbench latency.</p>

</dd>
<dt id="Efficient-Dynamic-Scheduling"><code>Efficient Dynamic Scheduling</code></dt>
<dd>

<p>To scale to more than a few threads, we may revisit a fully dynamic scheduler. For large (&gt;16 core) systems it might make sense to dedicate an entire core to scheduling, so that scheduler data structures would fit in its L1 cache and thus the cost of traversing priority-ordered ready lists would not be prohibitive.</p>

</dd>
<dt id="Static-Scheduling-with-Runtime-Repack"><code>Static Scheduling with Runtime Repack</code></dt>
<dd>

<p>We could modify the static scheduling approach by gathering actual macro-task execution times at run time, and dynamically re-packing the macro-tasks into the threads also at run time. Say, re-pack once every 10,000 cycles or something. This has the potential to do better than our static estimates about macro-task run times. It could potentially react to CPU cores that aren&#39;t performing equally, due to NUMA or thermal throttling or nonuniform competing memory traffic or whatever.</p>

</dd>
<dt id="Clock-Domain-Balancing"><code>Clock Domain Balancing</code></dt>
<dd>

<p>Right now Verilator makes no attempt to balance clock domains across macro-tasks. For a multi-domain model, that could lead to bad gantt chart fragmentation. This could be improved if it&#39;s a real problem in practice.</p>

</dd>
<dt id="Other-Forms-of-MTask-Balancing"><code>Other Forms of MTask Balancing</code></dt>
<dd>

<p>The largest source of runtime overhead is idle CPUs, which happens due to variance between our predicted runtime for each MTask and its actual runtime. That variance is magnified if MTasks are homogeneous, containing similar repeating logic which was generally close together in source code and which is still packed together even after going through Verilator&#39;s digestive tract.</p>

<p>If Verilator could avoid doing that, and instead would take source logic that was close together and distribute it across MTasks, that would increase the diversity of any given MTask, and this should reduce variance in the cost estimates.</p>

<p>One way to do that might be to make various &quot;tie breaker&quot; comparison routines in the sources to rely more heavily on randomness, and generally try harder not to keep input nodes together when we have the option to scramble things.</p>

</dd>
<dt id="Performance-Regression"><code>Performance Regression</code></dt>
<dd>

<p>It would be nice if we had a regression of large designs, with some diversity of design styles, to test on both single- and multi-threaded modes. This would help to avoid performance regressions, and also to evaluate the optimizations while minimizing the impact of parasitic noise.</p>

</dd>
<dt id="Per-Instance-Classes"><code>Per-Instance Classes</code></dt>
<dd>

<p>If we have multiple instances of the same module, and they partition differently (likely; we make no attempt to partition them the same) then the variable sort will be suboptimal for either instance. A possible improvement would be to emit a unique class for each instance of a module, and sort its variables optimally for that instance&#39;s code stream.</p>

</dd>
</dl>

<h2 id="Verilated-Flow">Verilated Flow</h2>

<p>The evaluation loop outputted by Verilator is designed to allow a single function to perform evaluation under most situations.</p>

<p>On the first evaluation, the Verilated code calls initial blocks, and then &quot;settles&quot; the modules, by evaluating functions (from always statements) until all signals are stable.</p>

<p>On other evaluations, the Verilated code detects what input signals have changes. If any are clocks, it calls the appropriate sequential functions (from always @ posedge statements). Interspersed with sequential functions it calls combo functions (from always @*). After this is complete, it detects any changes due to combo loops or internally generated clocks, and if one is found must reevaluate the model again.</p>

<p>For SystemC code, the eval() function is wrapped in a SystemC SC_METHOD, sensitive to all inputs. (Ideally it would only be sensitive to clocks and combo inputs, but tracing requires all signals to cause evaluation, and the performance difference is small.)</p>

<p>If tracing is enabled, a callback examines all variables in the design for changes, and writes the trace for each change. To accelerate this process the evaluation process records a bitmask of variables that might have changed; if clear, checking those signals for changes may be skipped.</p>

<h1 id="CODING-CONVENTIONS">CODING CONVENTIONS</h1>

<h2 id="Indentation-style">Indentation style</h2>

<p>To match the indentation of Verilator C++ sources, use 4 spaces per level, and leave tabs at 8 columns, so every other indent level is a tab stop.</p>

<p>All files should contain the magic header to insure standard indentation:</p>

<pre><code>    // -*- mode: C++; c-file-style: &quot;cc-mode&quot; -*-</code></pre>

<p>This sets indentation to the cc-mode defaults. (Verilator predates a CC-mode change of several years ago which overrides the defaults with GNU style indentation; the c-set-style undoes that.)</p>

<h2 id="The-astgen-script">The <code>astgen</code> script</h2>

<p>Some of the code implementing passes is extremely repetitive, and must be implemented for each sub-class of <code>AstNode</code>. However, while repetitive, there is more variability than can be handled in C++ macros.</p>

<p>In Verilator this is implemented by using a Perl script, <code>astgen</code> to pre-process the C++ code. For example in <code>V3Const.cpp</code> this is used to implement the <code>visit()</code> functions for each binary operation using the TREEOP macro.</p>

<p>The original C++ source code is transformed into C++ code in the <code>obj_opt</code> and <code>obj_dbg</code> sub-directories (the former for the optimized version of Verilator, the latter for the debug version). So for example <code>V3Const.cpp</code> into <code>V3Const__gen.cpp</code>.</p>

<h2 id="Visitor-Functions">Visitor Functions</h2>

<p>Verilator uses the <i>Visitor</i> design pattern to implement its refinement and optimization passes. This allows separation of the pass algorithm from the AST on which it operates. Wikipedia provides an introduction to the concept at <a href="http://en.wikipedia.org/wiki/Visitor_pattern">http://en.wikipedia.org/wiki/Visitor_pattern</a>.</p>

<p>As noted above, all visitors are derived classes of <code>AstNVisitor</code>. All derived classes of <code>AstNode</code> implement the <code>accept</code> method, which takes as argument a reference to an instance or a <code>AstNVisitor</code> derived class and applies the visit method of the <code>AstNVisitor</code> to the invoking AstNode instance (i.e. <code>this</code>).</p>

<p>One possible difficulty is that a call to <code>accept</code> may perform an edit which destroys the node it receives as argument. The <code>acceptSubtreeReturnEdits</code> method of <code>AstNode</code> is provided to apply <code>accept</code> and return the resulting node, even if the original node is destroyed (if it is not destroyed it will just return the original node).</p>

<p>The behavior of the visitor classes is achieved by overloading the <code>visit</code> function for the different <code>AstNode</code> derived classes. If a specific implementation is not found, the system will look in turn for overloaded implementations up the inheritance hierarchy. For example calling <code>accept</code> on <code>AstIf</code> will look in turn for:</p>

<pre><code>  void visit(AstIf* nodep)
  void visit(AstNodeIf* nodep)
  void visit(AstNodeStmt* nodep)
  void visit(AstNode* nodep)</code></pre>

<p>There are three ways data is passed between visitor functions.</p>

<ol>

<li><p>A visitor-class member variable. This is generally for passing &quot;parent&quot; information down to children. <code>m_modp</code> is a common example. It&#39;s set to NULL in the constructor, where that node (<code>AstModule</code> visitor) sets it, then the children are iterated, then it&#39;s cleared. Children under an <code>AstModule</code> will see it set, while nodes elsewhere will see it clear. If there can be nested items (for example an <code>AstFor</code> under an <code>AstFor</code>) the variable needs to be save-set-restored in the <code>AstFor</code> visitor, otherwise exiting the lower for will lose the upper for&#39;s setting.</p>

</li>
<li><p>User attributes. Each <code>AstNode</code> (<b>Note.</b> The AST node, not the visitor) has five user attributes, which may be accessed as an integer using the <code>user1()</code> through <code>user5()</code> methods, or as a pointer (of type <code>AstNUser</code>) using the <code>user1p()</code> through <code>user5p()</code> methods (a common technique lifted from graph traversal packages).</p>

<p>A visitor first clears the one it wants to use by calling <code>AstNode::user#ClearTree()</code>, then it can mark any node&#39;s user() with whatever data it wants. Readers just call <code>nodep-&gt;user()</code>, but may need to cast appropriately, so you&#39;ll often see <code>VN_CAST(nodep-&gt;userp(), SOMETYPE)</code>. At the top of each visitor are comments describing how the <code>user()</code> stuff applies to that visitor class. For example:</p>

<pre><code>    // NODE STATE
    // Cleared entire netlist
    //   AstModule::user1p()     // bool. True to inline this module</code></pre>

<p>This says that at the <code>AstNetlist</code> <code>user1ClearTree()</code> is called. Each <code>AstModule</code>&#39;s <code>user1()</code> is used to indicate if we&#39;re going to inline it.</p>

<p>These comments are important to make sure a <code>user#()</code> on a given <code>AstNode</code> type is never being used for two different purposes.</p>

<p>Note that calling <code>user#ClearTree</code> is fast, it doesn&#39;t walk the tree, so it&#39;s ok to call fairly often. For example, it&#39;s commonly called on every module.</p>

</li>
<li><p>Parameters can be passed between the visitors in close to the &quot;normal&quot; function caller to callee way. This is the second <code>vup</code> parameter of type <code>AstNUser</code> that is ignored on most of the visitor functions. V3Width does this, but it proved more messy than the above and is deprecated. (V3Width was nearly the first module written. Someday this scheme may be removed, as it slows the program down to have to pass vup everywhere.)</p>

</li>
</ol>

<h2 id="Iterators">Iterators</h2>

<p><code>AstNVisitor</code> provides a set of iterators to facilitate walking over the tree. Each operates on the current <code>AstNVisitor</code> class (as this) and takes an argument type <code>AstNode*</code>.</p>

<dl>

<dt id="iterate"><code>iterate</code></dt>
<dd>

<p>This just applies the <code>accept</code> method of the <code>AstNode</code> to the visitor function.</p>

</dd>
<dt id="iterateAndNextIgnoreEdit"><code>iterateAndNextIgnoreEdit</code></dt>
<dd>

<p>Applies the <code>accept</code> method of each <code>AstNode</code> in a list (i.e. connected by <code>nextp</code> and <code>backp</code> pointers).</p>

</dd>
<dt id="iterateAndNext"><code>iterateAndNext</code></dt>
<dd>

<p>Applies the <code>accept</code> method of each <code>AstNode</code> in a list. If a node is edited by the call to <code>accept</code>, apply <code>accept</code> again, until the node does not change.</p>

</dd>
<dt id="iterateListBackwards"><code>iterateListBackwards</code></dt>
<dd>

<p>Applies the <code>accept</code> method of each <code>AstNode</code> in a list, starting with the last one.</p>

</dd>
<dt id="iterateChildren"><code>iterateChildren</code></dt>
<dd>

<p>Apply the <code>iterateAndNext</code> method on each child <code>op1p</code> through <code>op4p</code> in turn.</p>

</dd>
<dt id="iterateChildrenBackwards"><code>iterateChildrenBackwards</code></dt>
<dd>

<p>Apply the <code>iterateListBackwards</code> method on each child <code>op1p</code> through <code>op4p</code> in turn.</p>

</dd>
</dl>

<h3 id="Caution-on-Using-Iterators-When-Child-Changes">Caution on Using Iterators When Child Changes</h3>

<p>Visitors often replace one node with another node; V3Width and V3Const are major examples. A visitor which is the parent of such a replacement needs to be aware that calling iteration may cause the children to change. For example:</p>

<pre><code>    // nodep-&gt;lhsp() is 0x1234000
    iterateAndNextNull(nodep-&gt;lhsp());  // and under covers nodep-&gt;lhsp() changes
    // nodep-&gt;lhsp() is 0x5678400
    iterateAndNextNull(nodep-&gt;lhsp());</code></pre>

<p>Will work fine, as even if the first iterate causes a new node to take the place of the lhsp(), that edit will update nodep-&gt;lhsp() and the second call will correctly see the change. Alternatively:</p>

<pre><code>    lp = nodep-&gt;lhsp();
    // nodep-&gt;lhsp() is 0x1234000, lp is 0x1234000
    iterateAndNextNull(lp); **lhsp=NULL;**  // and under covers nodep-&gt;lhsp() changes
    // nodep-&gt;lhsp() is 0x5678400, lp is 0x1234000
    iterateAndNextNull(lp);</code></pre>

<p>This will cause bugs or a core dump, as lp is a dangling pointer. Thus it is advisable to set lhsp=NULL shown in the *&#39;s above to make sure these dangles are avoided. Another alternative used in special cases mostly in V3Width is to use acceptSubtreeReturnEdits, which operates on a single node and returns the new pointer if any. Note acceptSubtreeReturnEdits does not follow nextp() links.</p>

<pre><code>    lp = acceptSubtreeReturnEdits(lp)</code></pre>

<h2 id="Identifying-derived-classes">Identifying derived classes</h2>

<p>A common requirement is to identify the specific <code>AstNode</code> class we are dealing with. For example a visitor might not implement separate <code>visit</code> methods for <code>AstIf</code> and <code>AstGenIf</code>, but just a single method for the base class:</p>

<pre><code>  void visit (AstNodeIf* nodep)</code></pre>

<p>However that method might want to specify additional code if it is called for <code>AstGenIf</code>. Verilator does this by providing a <code>VN_CAST</code> method for each possible node type, using C++ <code>dynamic_cast</code>. This either returns a pointer to the object cast to that type (if it is of class <code>SOMETYPE</code>, or a derived class of <code>SOMETYPE</code>) or else NULL. So our <code>visit</code> method could use:</p>

<pre><code>  if (VN_CAST(nodep, AstGenIf) {
      &lt;code specific to AstGenIf&gt;
  }</code></pre>

<p>A common test is for <code>AstNetlist</code>, which is the node at the root of the AST.</p>

<h1 id="TESTING">TESTING</h1>

<p>For an overview of how to write a test see the BUGS section of the Verilator primary manual.</p>

<p>It is important to add tests for failures as well as success (for example to check that an error message is correctly triggered).</p>

<p>Tests that fail should by convention have the suffix <code>_bad</code> in their name, and include <code>fails =&gt; 1</code> in either their <code>compile</code> or <code>execute</code> step as appropriate.</p>

<h2 id="Preparing-to-Run-Tests">Preparing to Run Tests</h2>

<p>For all tests to pass you must install the following packages:</p>

<p>* SystemC to compile the SystemC outputs, see http://systemc.org</p>

<p>* Parallel::Forker from CPAN to run tests in parallel, you can install this with e.g. &quot;sudo cpan install Parallel::Forker&quot;.</p>

<p>* vcddiff to find differences in VCD outputs. See the readme at https://github.com/veripool/vcddiff</p>

<h2 id="Controlling-the-Test-Driver">Controlling the Test Driver</h2>

<p>Test drivers are written in PERL. All invoke the main test driver script, which can provide detailed help on all the features available when writing a test driver.</p>

<pre><code>  test_regress/t/driver.pl --help</code></pre>

<p>For convenience, a summary of the most commonly used features is provided here. All drivers require a call to <code>compile</code> subroutine to compile the test. For run-time tests, this is followed by a call to the <code>execute</code> subroutine. Both of these functions can optionally be provided with a hash table as argument specifying additional options.</p>

<p>The test driver assumes by default that the source Verilog file name matches the PERL driver name. So a test whose driver is <code>t/t_mytest.pl</code> will expect a Verilog source file <code>t/t_mytest.v</code>. This can be changed using the <code>top_filename</code> subroutine, for example</p>

<pre><code>  top_filename(&quot;t/t_myothertest.v&quot;);</code></pre>

<p>By default all tests will run with major simulators (Icarus Verilog, NC, VCS, ModelSim) as well as Verilator, to allow results to be compared. However if you wish a test only to be used with Verilator, you can use the following:</p>

<pre><code>  $Self-&gt;{vlt} or $Self-&gt;skip(&quot;Verilator only test&quot;);</code></pre>

<p>Of the many options that can be set through arguments to <code>compiler</code> and <code>execute</code>, the following are particularly useful:</p>

<dl>

<dt id="verilator_flags2"><code>verilator_flags2</code></dt>
<dd>

<p>A list of flags to be passed to verilator when compiling.</p>

</dd>
<dt id="fails"><code>fails</code></dt>
<dd>

<p>Set to 1 to indicate that the compilation or execution is intended to fail.</p>

</dd>
</dl>

<p>For example the following would specify that compilation requires two defines and is expected to fail.</p>

<pre><code>  compile (
      verilator_flags2 =&gt; [&quot;-DSMALL_CLOCK -DGATED_COMMENT&quot;],
      fails =&gt; 1,
      );</code></pre>

<h2 id="Regression-Testing-for-Developers">Regression Testing for Developers</h2>

<p>Developers will also want to call ./configure with two extra flags:</p>

<dl>

<dt id="enable-ccwarn">--enable-ccwarn</dt>
<dd>

<p>Causes the build to stop on warnings as well as errors. A good way to ensure no sloppy code gets added, however it can be painful when it comes to testing, since third party code used in the tests (e.g. SystemC) may not be warning free.</p>

</dd>
<dt id="enable-longtests">--enable-longtests</dt>
<dd>

<p>In addition to the standard C, SystemC examples, also run the tests in the <code>test_regress</code> directory when using <i>make test</i>. This is disabled by default as SystemC installation problems would otherwise falsely indicate a Verilator problem.</p>

</dd>
</dl>

<p>When enabling the long tests, some additional PERL modules are needed, which you can install using cpan.</p>

<pre><code>    cpan install Unix::Processors</code></pre>

<p>There are some traps to avoid when running regression tests</p>

<ul>

<li><p>When checking the MANIFEST, the test will barf on unexpected code in the Verilator tree. So make sure to keep any such code outside the tree.</p>

</li>
<li><p>Not all Linux systems install Perldoc by default. This is needed for the <i>--help</i> option to Verilator, and also for regression testing. This can be installed using cpan:</p>

<pre><code>    cpan install Pod::Perldoc</code></pre>

<p>Many Linux systems also offer a standard package for this. Red Hat/Fedora/Centos offer <i>perl-Pod-Perldoc</i>, while Debian/Ubuntu/Linux Mint offer <i>perl-doc</i>.</p>

</li>
<li><p>Running regression may exhaust resources on some Linux systems, particularly file handles and user processes. Increase these to respectively 16,384 and 4,096. The method of doing this is system dependent, but on Fedora Linux it would require editing the <code>/etc/security/limits.conf</code> file as root.</p>

</li>
</ul>

<h1 id="DEBUGGING">DEBUGGING</h1>

<h2 id="debug">--debug</h2>

<p>When you run with --debug there are two primary output file types placed into the obj_dir, .tree and .dot files.</p>

<h2 id="dot-output">.dot output</h2>

<p>Dot files are dumps of internal graphs in Graphviz <a href="http://www.graphviz.org/">http://www.graphviz.org/</a> dot format. When a dot file is dumped, Verilator will also print a line on stdout that can be used to format the output, for example:</p>

<pre><code>    dot -Tps -o ~/a.ps obj_dir/Vtop_foo.dot</code></pre>

<p>You can then print a.ps. You may prefer gif format, which doesn&#39;t get scaled so can be more useful with large graphs.</p>

<p>For dynamic graph viewing consider ZGRViewer <a href="http://zvtm.sourceforge.net/zgrviewer.html">http://zvtm.sourceforge.net/zgrviewer.html</a>. If you know of better viewers let us know; ZGRViewer isn&#39;t great for large graphs.</p>

<h2 id="tree-output">.tree output</h2>

<p>Tree files are dumps of the AST Tree and are produced between every major algorithmic stage. An example:</p>

<pre><code>     NETLIST 0x90fb00 &lt;e1&gt; {a0}
    1: MODULE 0x912b20 &lt;e8822&gt; {a8}  top  L2 [P]
   *1:2: VAR 0x91a780 &lt;e74#&gt; {a22} @dt=0xa2e640(w32)  out_wide [O] WIRE
    1:2:1: BASICDTYPE 0xa2e640 &lt;e2149&gt; {e24} @dt=this(sw32)  integer kwd=integer range=[31:0]</code></pre>

<ul>

<p>The following summarizes the above example dump, with more detail on each field in the section below.</p>

<p>&quot;1:2:&quot; indicates the hierarchy of the <code>VAR</code> is the <code>op2p</code> pointer under the <code>MODULE</code>, which in turn is the <code>op1p</code> pointer under the <code>NETLIST</code></p>

<p>&quot;VAR&quot; is the AstNodeType.</p>

<p>&quot;0x91a780&quot; is the address of this node.</p>

<p>&quot;&lt;e74&gt;&quot; means the 74th edit to the netlist was the last modification to this node.</p>

<p>&quot;{a22}&quot; indicates this node is related to line 22 in the source filename &quot;a&quot;, where &quot;a&quot; is the first file read, &quot;z&quot; the 26th, and &quot;aa&quot; the 27th.</p>

<p>&quot;@dt=0x...&quot; indicates the address of the data type this node contains.</p>

<p>&quot;w32&quot; indicates the width is 32 bits.</p>

<p>&quot;out_wide&quot; is the name of the node, in this case the name of the variable.</p>

<p>&quot;[O]&quot; are flags which vary with the type of node, in this case it means the variable is an output.</p>

</ul>

<p>In more detail the following fields are dumped common to all nodes. They are produced by the <code>AstNode::dump()</code> method:</p>

<dl>

<dt id="Tree-Hierarchy">Tree Hierarchy</dt>
<dd>

<p>The dump lines begin with numbers and colons to indicate the child node hierarchy. As noted above in <a href="#Key-Classes-Used-in-the-Verilator-Flow">&quot;Key Classes Used in the Verilator Flow&quot;</a>, <code>AstNode</code> has lists of items at the same level in the AST, connected by the <code>nextp()</code> and <code>prevp()</code> pointers. These appear as nodes at the same level. For example after inlining:</p>

<pre><code>     NETLIST 0x929c1c8 &lt;e1&gt; {a0} w0
    1: MODULE 0x92bac80 &lt;e3144&gt; {e14} w0  TOP_t  L1 [P]
    1:1: CELLINLINE 0x92bab18 &lt;e3686#&gt; {e14} w0  v -&gt; t
    1:1: CELLINLINE 0x92bc1d8 &lt;e3688#&gt; {e24} w0  v__DOT__i_test_gen -&gt; test_gen
    ...
    1: MODULE 0x92b9bb0 &lt;e503&gt; {e47} w0  test_gen  L3
    ...</code></pre>

</dd>
<dt id="AstNode-type">AstNode type</dt>
<dd>

<p>The textual name of this node AST type (always in capitals). Many of these correspond directly to Verilog entities (for example <code>MODULE</code> and <code>TASK</code>), but others are internal to Verialtor (for example <code>NETLIST</code> and <code>BASICDTYPE</code>).</p>

</dd>
<dt id="Address-of-the-node">Address of the node</dt>
<dd>

<p>A hexadecimal address of the node in memory. Useful for examining with the debugger.</p>

</dd>
<dt id="Last-edit-number">Last edit number</dt>
<dd>

<p>Of the form <code>&lt;ennnn&gt;</code> or <code>&lt;ennnn#&gt;</code> , where <code>nnnn</code> is the number of the last edit to modify this node. The trailing <code>#</code> indicates the node has been edited since the last tree dump (which typically means in the last refinement or optimization pass). GDB can watch for this, see <a href="#Debugging-with-GDB">&quot;Debugging with GDB&quot;</a>.</p>

</dd>
<dt id="Source-file-and-line">Source file and line</dt>
<dd>

<p>Of the form <code>{xxnnnn}</code>, where C{xx} is the filename letter (or letters) and <code>nnnn</code> is the line number within that file. The first file is <code>a</code>, the 26th is <code>z</code>, the 27th is <code>aa</code> and so on.</p>

</dd>
<dt id="User-pointers">User pointers</dt>
<dd>

<p>Shows the value of the node&#39;s user1p...user5p, if non-NULL.</p>

</dd>
<dt id="Data-type">Data type</dt>
<dd>

<p>Many nodes have an explicit data type. &quot;@dt=0x...&quot; indicates the address of the data type (AstNodeDType) this node uses.</p>

<p>If a data type is present and is numeric, it then prints the width of the item. This field is a sequence of flag characters and width data as follows:</p>

<p><code>s</code> if the node is signed.</p>

<p><code>d</code> if the node is a double (i.e a floating point entity).</p>

<p><code>w</code> always present, indicating this is the width field.</p>

<p><code>u</code> if the node is unsized.</p>

<p><code>/nnnn</code> if the node is unsized, where <code>nnnn</code> is the minimum width.</p>

</dd>
<dt id="Name-of-the-entity-represented-by-the-node-if-it-exists">Name of the entity represented by the node if it exists</dt>
<dd>

<p>For example for a <code>VAR</code> it is the name of the variable.</p>

</dd>
</dl>

<p>Many nodes follow these fields with additional node specific information. Thus the <code>VARREF</code> node will print either <code>[LV]</code> or <code>[RV]</code> to indicate a left value or right value, followed by the node of the variable being referred to. For example:</p>

<pre><code>    1:2:1:1: VARREF 0x92c2598 &lt;e509&gt; {e24} w0  clk [RV] &lt;- VAR 0x92a2e90 &lt;e79&gt; {e18} w0  clk [I] INPUT</code></pre>

<p>In general, examine the <code>dump()</code> method in <code>V3AstNodes.cpp</code> of the node type in question to determine additional fields that may be printed.</p>

<p>The <code>MODULE</code> has a list of <code>CELLINLINE</code> nodes referred to by its <code>op1p()</code> pointer, connected by <code>nextp()</code> and <code>prevp()</code> pointers.</p>

<p>Similarly the <code>NETLIST</code> has a list of modules referred to by its <code>op1p()</code> pointer.</p>

<h2 id="Debugging-with-GDB">Debugging with GDB</h2>

<p>The test_regress/driver.pl script accepts --debug --gdb to start Verilator under gdb and break when an error is hit or the program is about to exit. You can also use --debug --gdbbt to just backtrace and then exit gdb. To debug the Verilated executable, use --gdbsim.</p>

<p>If you wish to start Verilator under GDB (or another debugger), then you can use --debug and look at the underlying invocation of verilator_dgb. For example</p>

<pre><code>  t/t_alw_dly.pl --debug</code></pre>

<p>shows it invokes the command:</p>

<pre><code>  ../verilator_bin_dbg --prefix Vt_alw_dly --x-assign unique --debug
    -cc -Mdir obj_dir/t_alw_dly --debug-check -f input.vc t/t_alw_dly.v</code></pre>

<p>Start GDB, then <code>start</code> with the remaining arguments.</p>

<pre><code>  gdb ../verilator_bin_dbg
  ...
  (gdb) start --prefix Vt_alw_dly --x-assign unique --debug -cc -Mdir
            obj_dir/t_alw_dly --debug-check  -f input.vc t/t_alw_dly.v
            &gt; obj_dir/t_alw_dly/vlt_compile.log
  ...
  Temporary breakpoint 1, main (argc=13, argv=0xbfffefa4, env=0xbfffefdc)
      at ../Verilator.cpp:615
  615         ios::sync_with_stdio();
  (gdb)</code></pre>

<p>You can then continue execution with breakpoints as required.</p>

<p>To break at a specific edit number which changed a node (presumably to find what made a &lt;e####&gt; line in the tree dumps):</p>

<pre><code>   watch AstNode::s_editCntGbl==####</code></pre>

<p>To print a node:</p>

<pre><code>   pn nodep
   # or: call nodep-&gt;dumpGdb() # aliased to &quot;pn&quot; in src/.gdbinit
   pnt nodep
   # or: call nodep-&gt;dumpTreeGdb()  # aliased to &quot;pnt&quot; in src/.gdbinit</code></pre>

<p>When GDB halts, it is useful to understand that the backtrace will commonly show the iterator functions between each invocation of <code>visit</code> in the backtrace. You will typically see a frame sequence something like</p>

<pre><code>  ...
  visit()
  iterateChildren()
  iterateAndNext()
  accept()
  visit()
  ...</code></pre>

<h1 id="ADDING-A-NEW-FEATURE">ADDING A NEW FEATURE</h1>

<p>Generally what would you do to add a new feature?</p>

<ol>

<li><p>File a bug (if there isn&#39;t already) so others know what you&#39;re working on.</p>

</li>
<li><p>Make a testcase in the test_regress/t/t_EXAMPLE format, see <a href="#TESTING">&quot;TESTING&quot;</a>.</p>

</li>
<li><p>If grammar changes are needed, look at the git version of VerilogPerl&#39;s src/VParseGrammar.y, as this grammar supports the full SystemVerilog language and has a lot of back-and-forth with Verilator&#39;s grammar. Copy the appropriate rules to src/verilog.y and modify the productions.</p>

</li>
<li><p>If a new Ast type is needed, add it to V3AstNodes.h.</p>

</li>
</ol>

<p>Now you can run &quot;test_regress/t/t_{new testcase}.pl --debug&quot; and it&#39;ll probably fail but you&#39;ll see a test_regress/obj_dir/t_{newtestcase}/*.tree file which you can examine to see if the parsing worked. See also the sections above on debugging.</p>

<p>Modify the later visitor functions to process the new feature as needed.</p>

<h2 id="Adding-a-new-pass">Adding a new pass</h2>

<p>For more substantial changes you may need to add a new pass. The simplest way to do this is to copy the <code>.cpp</code> and <code>.h</code> files from an existing pass. You&#39;ll need to add a call into your pass from the <code>process()</code> function in <code>src/verilator.cpp</code>.</p>

<p>To get your pass to build you&#39;ll need to add its binary filename to the list in <code>src/Makefile_obj.in</code> and reconfigure.</p>

<h1 id="DISTRIBUTION">DISTRIBUTION</h1>

<p>The latest version is available from <a href="http://www.veripool.org/">http://www.veripool.org/</a>.</p>

<p>Copyright 2008-2019 by Wilson Snyder. Verilator is free software; you can redistribute it and/or modify it under the terms of either the GNU Lesser General Public License Version 3 or the Perl Artistic License Version 2.0.</p>


</body>

</html>


