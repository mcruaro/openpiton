<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#ARGUMENT-SUMMARY">ARGUMENT SUMMARY</a></li>
  <li><a href="#VERILATION-ARGUMENTS">VERILATION ARGUMENTS</a></li>
  <li><a href="#RUNTIME-ARGUMENTS">RUNTIME ARGUMENTS</a></li>
  <li><a href="#EXAMPLE-C-EXECUTION">EXAMPLE C++ EXECUTION</a></li>
  <li><a href="#EXAMPLE-SYSTEMC-EXECUTION">EXAMPLE SYSTEMC EXECUTION</a></li>
  <li><a href="#BENCHMARKING-OPTIMIZATION">BENCHMARKING &amp; OPTIMIZATION</a></li>
  <li><a href="#FILES">FILES</a></li>
  <li><a href="#ENVIRONMENT">ENVIRONMENT</a></li>
  <li><a href="#CONNECTING-TO-C">CONNECTING TO C++</a></li>
  <li><a href="#CONNECTING-TO-SYSTEMC">CONNECTING TO SYSTEMC</a></li>
  <li><a href="#DIRECT-PROGRAMMING-INTERFACE-DPI">DIRECT PROGRAMMING INTERFACE (DPI)</a>
    <ul>
      <li><a href="#DPI-Example">DPI Example</a></li>
      <li><a href="#DPI-System-Task-Functions">DPI System Task/Functions</a></li>
      <li><a href="#DPI-Display-Functions">DPI Display Functions</a></li>
      <li><a href="#DPI-Context-Functions">DPI Context Functions</a></li>
      <li><a href="#DPI-Header-Isolation">DPI Header Isolation</a></li>
      <li><a href="#Public-Functions">Public Functions</a></li>
    </ul>
  </li>
  <li><a href="#VERIFICATION-PROCEDURAL-INTERFACE-VPI">VERIFICATION PROCEDURAL INTERFACE (VPI)</a>
    <ul>
      <li><a href="#VPI-Example">VPI Example</a></li>
    </ul>
  </li>
  <li><a href="#CROSS-COMPILATION">CROSS COMPILATION</a>
    <ul>
      <li><a href="#Cadence-NC-SystemC-Models">Cadence NC-SystemC Models</a></li>
    </ul>
  </li>
  <li><a href="#MULTITHREADING">MULTITHREADING</a>
    <ul>
      <li><a href="#Multithreaded-Verilog-and-Library-Support">Multithreaded Verilog and Library Support</a></li>
    </ul>
  </li>
  <li><a href="#CONFIGURATION-FILES">CONFIGURATION FILES</a></li>
  <li><a href="#LANGUAGE-STANDARD-SUPPORT">LANGUAGE STANDARD SUPPORT</a>
    <ul>
      <li><a href="#Verilog-2001-IEEE-1364-2001-Support">Verilog 2001 (IEEE 1364-2001) Support</a></li>
      <li><a href="#Verilog-2005-IEEE-1364-2005-Support">Verilog 2005 (IEEE 1364-2005) Support</a></li>
      <li><a href="#SystemVerilog-2005-IEEE-1800-2005-Support">SystemVerilog 2005 (IEEE 1800-2005) Support</a></li>
      <li><a href="#SystemVerilog-2012-IEEE-1800-2012-Support">SystemVerilog 2012 (IEEE 1800-2012) Support</a></li>
      <li><a href="#SystemVerilog-2017-IEEE-1800-2017-Support">SystemVerilog 2017 (IEEE 1800-2017) Support</a></li>
      <li><a href="#Verilog-AMS-Support">Verilog AMS Support</a></li>
      <li><a href="#Synthesis-Directive-Assertion-Support">Synthesis Directive Assertion Support</a></li>
    </ul>
  </li>
  <li><a href="#LANGUAGE-EXTENSIONS">LANGUAGE EXTENSIONS</a></li>
  <li><a href="#LANGUAGE-LIMITATIONS">LANGUAGE LIMITATIONS</a>
    <ul>
      <li><a href="#Synthesis-Subset">Synthesis Subset</a></li>
      <li><a href="#Signal-Naming">Signal Naming</a></li>
      <li><a href="#Bind">Bind</a></li>
      <li><a href="#Dotted-cross-hierarchy-references">Dotted cross-hierarchy references</a></li>
      <li><a href="#Floating-Point">Floating Point</a></li>
      <li><a href="#Latches">Latches</a></li>
      <li><a href="#Structures-and-Unions">Structures and Unions</a></li>
      <li><a href="#Time">Time</a></li>
      <li><a href="#Unknown-states">Unknown states</a></li>
      <li><a href="#Tri-Inout">Tri/Inout</a></li>
      <li><a href="#Functions-Tasks">Functions &amp; Tasks</a></li>
      <li><a href="#Generated-Clocks">Generated Clocks</a></li>
      <li><a href="#Ranges-must-be-big-bit-endian">Ranges must be big-bit-endian</a></li>
      <li><a href="#Gate-Primitives">Gate Primitives</a></li>
      <li><a href="#Specify-blocks">Specify blocks</a></li>
      <li><a href="#Array-Initialization">Array Initialization</a></li>
      <li><a href="#Array-Out-of-Bounds">Array Out of Bounds</a></li>
      <li><a href="#Assertions">Assertions</a></li>
      <li><a href="#Language-Keyword-Limitations">Language Keyword Limitations</a></li>
    </ul>
  </li>
  <li><a href="#ERRORS-AND-WARNINGS">ERRORS AND WARNINGS</a></li>
  <li><a href="#FAQ-FREQUENTLY-ASKED-QUESTIONS">FAQ/FREQUENTLY ASKED QUESTIONS</a></li>
  <li><a href="#BUGS">BUGS</a></li>
  <li><a href="#HISTORY">HISTORY</a></li>
  <li><a href="#AUTHORS">AUTHORS</a></li>
  <li><a href="#CONTRIBUTORS">CONTRIBUTORS</a></li>
  <li><a href="#DISTRIBUTION">DISTRIBUTION</a></li>
  <li><a href="#SEE-ALSO">SEE ALSO</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Verilator - Convert Verilog code to C++/SystemC</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code>    verilator --help
    verilator --version
    verilator --cc [options] [source_files.v]... [opt_c_files.cpp/c/cc/a/o/so]
    verilator --sc [options] [source_files.v]... [opt_c_files.cpp/c/cc/a/o/so]
    verilator --lint-only -Wall [source_files.v]...</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>Verilator converts synthesizable (generally not behavioral) Verilog code, plus some Synthesis, SystemVerilog and a small subset of Verilog AMS into C++ or SystemC code. It is not a complete simulator, but a compiler.</p>

<p>Verilator is invoked with parameters similar to GCC, Cadence Verilog-XL/NC-Verilog, or Synopsys&#39;s VCS. It reads the specified Verilog code, lints it, and optionally adds coverage and waveform tracing code. For C++ and SystemC formats, it outputs .cpp and .h files.</p>

<p>The files created by Verilator are then compiled with C++. The user writes a little C++ wrapper file, which instantiates the top level module, and passes this filename on the command line. These C files are compiled in C++, and linked with the Verilated files.</p>

<p>The resulting executable will perform the actual simulation.</p>

<p>To get started, jump down to &quot;EXAMPLE C++ EXECUTION&quot;.</p>

<h1 id="ARGUMENT-SUMMARY">ARGUMENT SUMMARY</h1>

<p>This is a short summary of the arguments to Verilator itself. See the detailed descriptions in <a href="#VERILATION-ARGUMENTS">&quot;VERILATION ARGUMENTS&quot;</a> for more information.</p>

<pre><code>    {file.v}                    Verilog package, module and top module filenames
    {file.c/cc/cpp}             Optional C++ files to compile in
    {file.a/o/so}               Optional C++ files to link in

     +1364-1995ext+&lt;ext&gt;        Use Verilog 1995 with file extension &lt;ext&gt;
     +1364-2001ext+&lt;ext&gt;        Use Verilog 2001 with file extension &lt;ext&gt;
     +1364-2005ext+&lt;ext&gt;        Use Verilog 2005 with file extension &lt;ext&gt;
     +1800-2005ext+&lt;ext&gt;        Use SystemVerilog 2005 with file extension &lt;ext&gt;
     +1800-2009ext+&lt;ext&gt;        Use SystemVerilog 2009 with file extension &lt;ext&gt;
     +1800-2012ext+&lt;ext&gt;        Use SystemVerilog 2012 with file extension &lt;ext&gt;
     +1800-2017ext+&lt;ext&gt;        Use SystemVerilog 2017 with file extension &lt;ext&gt;
    --assert                    Enable all assertions
    --autoflush                 Flush streams after all $displays
    --bbox-sys                  Blackbox unknown $system calls
    --bbox-unsup                Blackbox unsupported language features
    --bin &lt;filename&gt;            Override Verilator binary
     -CFLAGS &lt;flags&gt;            C++ Compiler flags for makefile
    --cc                        Create C++ output
    --cdc                       Clock domain crossing analysis
    --clk &lt;signal-name&gt;         Mark specified signal as clock
    --compiler &lt;compiler-name&gt;  Tune for specified C++ compiler
    --converge-limit &lt;loops&gt;    Tune convergence settle time
    --coverage                  Enable all coverage
    --coverage-line             Enable line coverage
    --coverage-toggle           Enable toggle coverage
    --coverage-user             Enable SVL user coverage
    --coverage-underscore       Enable coverage of _signals
     -D&lt;var&gt;[=&lt;value&gt;]          Set preprocessor define
    --debug                     Enable debugging
    --debug-check               Enable debugging assertions
    --no-debug-leak             Disable leaking memory in --debug mode
    --debugi &lt;level&gt;            Enable debugging at a specified level
    --debugi-&lt;srcfile&gt; &lt;level&gt;  Enable debugging a source file at a level
    --default-language &lt;lang&gt;   Default language to parse
     +define+&lt;var&gt;=&lt;value&gt;      Set preprocessor define
    --dump-defines              Show preprocessor defines with -E
    --dump-tree                 Enable dumping .tree files
    --dump-treei &lt;level&gt;        Enable dumping .tree files at a level
    --dump-treei-&lt;srcfile&gt; &lt;level&gt;  Enable dumping .tree file at a source file at a level
     -E                         Preprocess, but do not compile
    --error-limit &lt;value&gt;       Abort after this number of errors
    --exe                       Link to create executable
     -F &lt;file&gt;                  Parse options from a file, relatively
     -f &lt;file&gt;                  Parse options from a file
     -FI &lt;file&gt;                 Force include of a file
     -G&lt;name&gt;=&lt;value&gt;           Overwrite toplevel parameter
    --gdb                       Run Verilator under GDB interactively
    --gdbbt                     Run Verilator under GDB for backtrace
    --getenv &lt;var&gt;              Get environment variable with defaults
    --help                      Display this help
     -I&lt;dir&gt;                    Directory to search for includes
    --gate-stmts &lt;value&gt;        Tune gate optimizer depth
    --if-depth &lt;value&gt;          Tune IFDEPTH warning
     +incdir+&lt;dir&gt;              Directory to search for includes
    --inhibit-sim               Create function to turn off sim
    --inline-mult &lt;value&gt;       Tune module inlining
     -LDFLAGS &lt;flags&gt;           Linker pre-object flags for makefile
     -LDLIBS &lt;flags&gt;            Linker library flags for makefile
    --l2-name &lt;value&gt;           Verilog scope name of the top module
    --language &lt;lang&gt;           Default language standard to parse
     +libext+&lt;ext&gt;+[ext]...     Extensions for finding modules
    --lint-only                 Lint, but do not make output
    --MMD                       Create .d dependency files
    --MP                        Create phony dependency targets
    --Mdir &lt;directory&gt;          Name of output object directory
    --mod-prefix &lt;topname&gt;      Name to prepend to lower classes
    --no-clk &lt;signal-name&gt;      Prevent marking specified signal as clock
    --no-decoration             Disable comments and symbol decorations
    --no-pins64                 Don&#39;t use vluint64_t&#39;s for 33-64 bit sigs
    --no-skip-identical         Disable skipping identical output
     +notimingchecks            Ignored
     -O0                        Disable optimizations
     -O3                        High performance optimizations
     -O&lt;optimization-letter&gt;    Selectable optimizations
     -o &lt;executable&gt;            Name of final executable
    --no-order-clock-delay      Disable ordering clock enable assignments
    --output-split &lt;bytes&gt;      Split .cpp files into pieces
    --output-split-cfuncs &lt;statements&gt;   Split .cpp functions
    --output-split-ctrace &lt;statements&gt;   Split tracing functions
     -P                         Disable line numbers and blanks with -E
    --pins-bv &lt;bits&gt;            Specify types for top level ports
    --pins-sc-uint              Specify types for top level ports
    --pins-sc-biguint           Specify types for top level ports
    --pins-uint8                Specify types for top level ports
    --pipe-filter &lt;command&gt;     Filter all input through a script
    --pp-comments               Show preprocessor comments with -E
    --prefix &lt;topname&gt;          Name of top level class
    --prof-cfuncs               Name functions for profiling
    --prof-threads              Enable generating gantt chart data for threads
    --private                   Debugging; see docs
    --public                    Debugging; see docs
     -pvalue+&lt;name&gt;=&lt;value&gt;     Overwrite toplevel parameter
    --relative-includes         Resolve includes relative to current file
    --no-relative-cfuncs        Disallow &#39;this-&gt;&#39; in generated functions
    --report-unoptflat          Extra diagnostics for UNOPTFLAT
    --savable                   Enable model save-restore
    --sc                        Create SystemC output
    --stats                     Create statistics file
    --stats-vars                Provide statistics on variables
     -sv                        Enable SystemVerilog parsing
     +systemverilogext+&lt;ext&gt;    Synonym for +1800-2017ext+&lt;ext&gt;
    --threads &lt;threads&gt;         Enable multithreading
    --threads-dpi &lt;mode&gt;        Enable multithreaded DPI
    --threads-max-mtasks &lt;mtasks&gt;  Tune maximum mtask partitioning
    --top-module &lt;topname&gt;      Name of top level input module
    --trace                     Enable waveform creation
    --trace-fst                 Enable FST waveform creation
    --trace-fst-thread          Enable FST threaded waveform creation
    --trace-depth &lt;levels&gt;      Depth of tracing
    --trace-max-array &lt;depth&gt;   Maximum bit width for tracing
    --trace-max-width &lt;width&gt;   Maximum array depth for tracing
    --trace-params              Enable tracing parameters
    --trace-structs             Enable tracing structure names
    --trace-underscore          Enable tracing of _signals
     -U&lt;var&gt;                    Undefine preprocessor define
    --unroll-count &lt;loops&gt;      Tune maximum loop iterations
    --unroll-stmts &lt;stmts&gt;      Tune maximum loop body size
    --unused-regexp &lt;regexp&gt;    Tune UNUSED lint signals
     -V                         Verbose version and config
     -v &lt;filename&gt;              Verilog library
     +verilog1995ext+&lt;ext&gt;      Synonym for +1364-1995ext+&lt;ext&gt;
     +verilog2001ext+&lt;ext&gt;      Synonym for +1364-2001ext+&lt;ext&gt;
    --version                   Displays program version and exits
    --vpi                       Enable VPI compiles
     -Wall                      Enable all style warnings
     -Werror-&lt;message&gt;          Convert warnings to errors
     -Wfuture-&lt;message&gt;         Disable unknown message warnings
     -Wno-&lt;message&gt;             Disable warning
     -Wno-lint                  Disable all lint warnings
     -Wno-style                 Disable all style warnings
     -Wno-fatal                 Disable fatal exit on warnings
    --x-assign &lt;mode&gt;           Assign non-initial Xs to this value
    --x-initial &lt;mode&gt;          Assign initial Xs to this value
    --x-initial-edge            Enable initial X-&gt;0 and X-&gt;1 edge triggers
    --xml-only                  Create XML parser output
     -y &lt;dir&gt;                   Directory to search for modules</code></pre>

<p>This is a short summary of the arguments to run-time Verilated arguments. detailed descriptions in <a href="#RUNTIME-ARGUMENTS">&quot;RUNTIME ARGUMENTS&quot;</a> for more information.</p>

<pre><code>     +verilator+debug                  Enable debugging
     +verilator+debugi+&lt;value&gt;         Enable debugging at a level
     +verilator+help                   Display help
     +verilator+prof+threads+file+I&lt;filename&gt;  Set profile filename
     +verilator+prof+threads+start+I&lt;value&gt;    Set profile starting point
     +verilator+prof+threads+window+I&lt;value&gt;   Set profile duration
     +verilator+rand+reset+I&lt;value&gt;    Set random reset technique
     +verilator+seed+I&lt;value&gt;          Set random seed
     +verilator+V                      Verbose version and config
     +verilator+version                Show version and exit</code></pre>

<h1 id="VERILATION-ARGUMENTS">VERILATION ARGUMENTS</h1>

<p>The following are the arguments that may be passed to Verilator itself.</p>

<dl>

<dt id="file.v">{file.v}</dt>
<dd>

<p>Specifies the Verilog file containing the top module to be Verilated.</p>

</dd>
<dt id="file.c-.cc-.cpp-.cxx">{file.c/.cc/.cpp/.cxx}</dt>
<dd>

<p>Specifies optional C++ files to be linked in with the Verilog code. The file path should either be absolute, or relative to where the make will be executed from, or add to your makefile&#39;s VPATH the appropriate directory to find the file.</p>

<p>If any C++ files are specified in this way, Verilator will include a make rule that generates a <i>module</i> executable. Without any C++ files, Verilator will stop at the <i>module</i>__ALL.a library, and presume you&#39;ll continue linking with make rules you write yourself. See also the -CFLAGS option.</p>

</dd>
<dt id="file.a-.o-.so">{file.a/.o/.so}</dt>
<dd>

<p>Specifies optional object or library files to be linked in with the Verilog code, as a shorthand for -LDFLAGS &quot;&lt;file&gt;&quot;. The file path should either be absolute, or relative to where the make will be executed from, or add to your makefile&#39;s VPATH the appropriate directory to find the file.</p>

<p>If any files are specified in this way, Verilator will include a make rule that uses these files when linking the <i>module</i> executable. This generally is only useful when used with the --exe option.</p>

</dd>
<dt id="ext-ext">+1364-1995ext+<i>ext</i></dt>
<dd>

</dd>
<dt id="ext-ext1">+1364-2001ext+<i>ext</i></dt>
<dd>

</dd>
<dt id="ext-ext2">+1364-2005ext+<i>ext</i></dt>
<dd>

</dd>
<dt id="ext-ext3">+1800-2005ext+<i>ext</i></dt>
<dd>

</dd>
<dt id="ext-ext4">+1800-2009ext+<i>ext</i></dt>
<dd>

</dd>
<dt id="ext-ext5">+1800-2012ext+<i>ext</i></dt>
<dd>

</dd>
<dt id="ext-ext6">+1800-2017ext+<i>ext</i></dt>
<dd>

<p>Specifies the language standard to be used with a specific filename extension, <i>ext</i>.</p>

<p>For compatibility with other simulators, see also the synonyms <code>+verilog1995ext+</code><i>ext</i>, <code>+verilog2001ext+</code><i>ext</i>, and <code>+systemverilogext+</code><i>ext</i>.</p>

<p>For any source file, the language specified by these options takes precedence over any language specified by the <code>--default-language</code> or <code>--language</code> options.</p>

<p>These options take effect in the order they are encountered. Thus the following would use Verilog 1995 for <code>a.v</code> and Verilog 2001 for <code>b.v</code>.</p>

<pre><code>    verilator ... +1364-1995ext+v a.v +1364-2001ext+v b.v</code></pre>

<p>These flags are only recommended for legacy mixed language designs, as the preferable option is to edit the code to repair new keywords, or add appropriate <code>`begin_keywords</code>.</p>

<p><b>Note</b> <code>`begin_keywords</code> is a SystemVerilog construct, which specifies <i>only</i> which the set of keywords is to be recognized. Whatever set is chosen, the semantics will be those of SystemVerilog. By contrast <code>+1364-1995ext+</code> etc. specify both the syntax <i>and</i> semantics to be used.</p>

</dd>
<dt id="assert">--assert</dt>
<dd>

<p>Enable all assertions.</p>

</dd>
<dt id="autoflush">--autoflush</dt>
<dd>

<p>After every $display or $fdisplay, flush the output stream. This ensures that messages will appear immediately but may reduce performance; for best performance call &quot;fflush(stdout)&quot; occasionally in the main C loop. Defaults off, which will buffer output as provided by the normal C stdio calls.</p>

</dd>
<dt id="bbox-sys">--bbox-sys</dt>
<dd>

<p>Black box any unknown $system task or function calls. System tasks will be simply NOPed, and system functions will be replaced by unsized zero. Arguments to such functions will be parsed, but not otherwise checked. This prevents errors when linting in the presence of company specific PLI calls.</p>

</dd>
<dt id="bbox-unsup">--bbox-unsup</dt>
<dd>

<p>Black box some unsupported language features, currently UDP tables, the cmos and tran gate primitives, deassign statements, and mixed edge errors. This may enable linting the rest of the design even when unsupported constructs are present.</p>

</dd>
<dt id="bin-filename">--bin <i>filename</i></dt>
<dd>

<p>Rarely needed. Override the default filename for Verilator itself. When a dependency (.d) file is created, this filename will become a source dependency, such that a change in this binary will have make rebuild the output files.</p>

</dd>
<dt id="CFLAGS-flags">-CFLAGS <i>flags</i></dt>
<dd>

<p>Add specified C compiler flag to the generated makefiles. For multiple flags either pass them as a single argument with space separators quoted in the shell (<code>-CFLAGS &quot;-a -b&quot;</code>), or use multiple -CFLAGS arguments (<code>-CFLAGS -a -CFLAGS -b</code>).</p>

<p>When make is run on the generated makefile these will be passed to the C++ compiler (gcc/g++/msvc++).</p>

</dd>
<dt id="cc">--cc</dt>
<dd>

<p>Specifies C++ without SystemC output mode; see also --sc.</p>

</dd>
<dt id="cdc">--cdc</dt>
<dd>

<p>Experimental. Perform some clock domain crossing checks and issue related warnings (CDCRSTLOGIC) and then exit; if warnings other than CDC warnings are needed make a second run with --lint-only. Additional warning information is also written to the file {prefix}__cdc.txt.</p>

<p>Currently only checks some items that other CDC tools missed; if you have interest in adding more traditional CDC checks, please contact the authors.</p>

</dd>
<dt id="clk-signal-name">--clk <i>signal-name</i></dt>
<dd>

<p>Sometimes it is quite difficult for Verilator to distinguish clock signals from other data signals. Occasionally the clock signals can end up in the checking list of signals which determines if further evaluation is needed. This will heavily degrade the performance of a Verilated model.</p>

<p>With --clk &lt;signal-name&gt;, user can specified root clock into the model, then Verilator will mark the signal as clocker and propagate the clocker attribute automatically to other signals derived from that. In this way, Verilator will try to avoid taking the clocker signal into checking list.</p>

<p>Note signal-name is specified by the RTL hierarchy path. For example, v.foo.bar. If the signal is the input to top-module, the directly the signal name. If you find it difficult to find the exact name, try to use <code>/*verilator clocker*/</code> in RTL file to mark the signal directly.</p>

<p>If clock signals are assigned to vectors and then later used individually, Verilator will attempt to decompose the vector and connect the single-bit clock signals directly. This should be transparent to the user.</p>

</dd>
<dt id="compiler-compiler-name">--compiler <i>compiler-name</i></dt>
<dd>

<p>Enables tunings and workarounds for the specified C++ compiler.</p>

<dl>

<dt id="clang">clang</dt>
<dd>

<p>Tune for clang. This may reduce execution speed as it enables several workarounds to avoid silly hardcoded limits in clang. This includes breaking deep structures as for msvc as described below.</p>

</dd>
<dt id="gcc">gcc</dt>
<dd>

<p>Tune for GNU C++, although generated code should work on almost any compliant C++ compiler. Currently the default.</p>

</dd>
<dt id="msvc">msvc</dt>
<dd>

<p>Tune for Microsoft Visual C++. This may reduce execution speed as it enables several workarounds to avoid silly hardcoded limits in MSVC++. This includes breaking deeply nested parenthesized expressions into sub-expressions to avoid error C1009, and breaking deep blocks into functions to avoid error C1061.</p>

</dd>
</dl>

</dd>
<dt id="converge-limit-loops">--converge-limit <i>loops</i></dt>
<dd>

<p>Rarely needed. Specifies the maximum number of runtime iterations before creating a model failed to converge error. Defaults to 100.</p>

</dd>
<dt id="coverage">--coverage</dt>
<dd>

<p>Enables all forms of coverage, alias for &quot;--coverage-line --coverage-toggle --coverage-user&quot;.</p>

</dd>
<dt id="coverage-line">--coverage-line</dt>
<dd>

<p>Specifies basic block line coverage analysis code should be inserted.</p>

<p>Coverage analysis adds statements at each code flow change point, which are the branches of IF and CASE statements, a super-set of normal Verilog Line Coverage. At each such branch a unique counter is incremented. At the end of a test, the counters along with the filename and line number corresponding to each counter are written into logs/coverage.dat.</p>

<p>Verilator automatically disables coverage of branches that have a $stop in them, as it is assumed $stop branches contain an error check that should not occur. A /*verilator coverage_block_off*/ comment will perform a similar function on any code in that block or below, or /*verilator coverage_on/coverage_off*/ will disable coverage around lines of code.</p>

<p>Note Verilator may over-count combinatorial (non-clocked) blocks when those blocks receive signals which have had the UNOPTFLAT warning disabled; for most accurate results do not disable this warning when using coverage.</p>

</dd>
<dt id="coverage-toggle">--coverage-toggle</dt>
<dd>

<p>Specifies signal toggle coverage analysis code should be inserted.</p>

<p>Every bit of every signal in a module has a counter inserted. The counter will increment on every edge change of the corresponding bit.</p>

<p>Signals that are part of tasks or begin/end blocks are considered local variables and are not covered. Signals that begin with underscores, are integers, or are very wide (&gt;256 bits total storage across all dimensions) are also not covered.</p>

<p>Hierarchy is compressed, such that if a module is instantiated multiple times, coverage will be summed for that bit across ALL instantiations of that module with the same parameter set. A module instantiated with different parameter values is considered a different module, and will get counted separately.</p>

<p>Verilator makes a minimally-intelligent decision about what clock domain the signal goes to, and only looks for edges in that clock domain. This means that edges may be ignored if it is known that the edge could never be seen by the receiving logic. This algorithm may improve in the future. The net result is coverage may be lower than what would be seen by looking at traces, but the coverage is a more accurate representation of the quality of stimulus into the design.</p>

<p>There may be edges counted near time zero while the model stabilizes. It&#39;s a good practice to zero all coverage just before releasing reset to prevent counting such behavior.</p>

<p>A /*verilator coverage_off/on */ comment pair can be used around signals that do not need toggle analysis, such as RAMs and register files.</p>

</dd>
<dt id="coverage-underscore">--coverage-underscore</dt>
<dd>

<p>Enable coverage of signals that start with an underscore. Normally, these signals are not covered. See also --trace-underscore.</p>

</dd>
<dt id="coverage-user">--coverage-user</dt>
<dd>

<p>Enables user inserted functional coverage. Currently, all functional coverage points are specified using SVA which must be separately enabled with --assert.</p>

<p>For example, the following statement will add a coverage point, with the comment &quot;DefaultClock&quot;:</p>

<pre><code>   DefaultClock: cover property (@(posedge clk) cyc==3);</code></pre>

</dd>
<dt id="Dvar-value">-D<i>var</i>=<i>value</i></dt>
<dd>

<p>Defines the given preprocessor symbol, without allowing. Similar to +define; +define is fairly standard across Verilog tools while -D is an alias for GCC compatibility.</p>

</dd>
<dt id="debug">--debug</dt>
<dd>

<p>Select the debug built image of Verilator (if available), and enable more internal assertions (equivalent to <code>--debug-check</code>), debugging messages (equivalent to <code>--debugi 4</code>), and intermediate form dump files (equivalent to <code>--dump-treei 3</code>).</p>

</dd>
<dt id="debug-check">--debug-check</dt>
<dd>

<p>Rarely needed. Enable internal debugging assertion checks, without changing debug verbosity. Enabled automatically when --debug specified.</p>

</dd>
<dt id="no-debug-leak">--no-debug-leak</dt>
<dd>

<p>In --debug mode, by default Verilator intentionally leaks AstNode&#39;s instead of freeing them, so that each node pointer is unique in the resulting tree files and dot files.</p>

<p>This option disables the leak. This may avoid out-of-memory errors when Verilating large models in --debug mode.</p>

<p>Outside of --debug mode, AstNode&#39;s should never be leaked and this option has no effect.</p>

</dd>
<dt id="debugi-level">--debugi <i>level</i></dt>
<dd>

</dd>
<dt id="debugi-srcfile-level">--debugi-<i>srcfile</i> <i>level</i></dt>
<dd>

<p>Rarely needed - for developer use. Set internal debugging level globally to the specified debug level (1-10) or set the specified Verilator source file to the specified level (e.g. <code>--debugi-V3Width 9</code>). Higher levels produce more detailed messages.</p>

</dd>
<dt id="default-language-value">--default-language <i>value</i></dt>
<dd>

<p>Select the language to be used by default when first processing each Verilog file. The language value must be &quot;1364-1995&quot;, &quot;1364-2001&quot;, &quot;1364-2005&quot;, &quot;1800-2005&quot;, &quot;1800-2009&quot;, &quot;1800-2012&quot; or &quot;1800-2017&quot;.</p>

<p>Any language associated with a particular file extension (see the various +<i>lang</i>ext+ options) will be used in preference to the language specified by --default-language.</p>

<p>The --default-language flag is only recommended for legacy code using the same language in all source files, as the preferable option is to edit the code to repair new keywords, or add appropriate <code>`begin_keywords</code>. For legacy mixed language designs, the various +<i>lang</i>ext+ options should be used.</p>

<p>If no language is specified, either by this flag or +<i>lang</i>ext+ options, then the latest SystemVerilog language (IEEE 1800-2017) is used.</p>

</dd>
<dt id="define-var-value">+define+<i>var</i>=<i>value</i></dt>
<dd>

</dd>
<dt id="define-var-value-var2-value2">+define+<i>var</i>=<i>value</i>+<i>var2</i>=<i>value2</i>...</dt>
<dd>

<p>Defines the given preprocessor symbol, or multiple symbols if separated by plusses. Similar to -D; +define is fairly standard across Verilog tools while -D is an alias for GCC compatibility.</p>

</dd>
<dt id="dump-defines">--dump-defines</dt>
<dd>

<p>With -E, suppress normal output, and instead print a list of all defines existing at the end of pre-processing the input files. Similar to GCC &quot;-dM&quot; option. This also gives you a way of finding out what is predefined in Verilator using the command:</p>

<pre><code>   touch foo.v ; verilator -E --dump-defines foo.v</code></pre>

</dd>
<dt id="dump-tree">--dump-tree</dt>
<dd>

<p>Rarely needed. Enable writing .tree debug files with dumping level 3, which dumps the standard critical stages. For details on the format see the Verilator Internals manual. --dump-tree is enabled automatically with --debug, so &quot;--debug --no-dump-tree&quot; may be useful if the dump files are large and not desired.</p>

</dd>
<dt id="dump-treei-level">--dump-treei <i>level</i></dt>
<dd>

</dd>
<dt id="dump-treei-srcfile-level">--dump-treei-<i>srcfile</i> <i>level</i></dt>
<dd>

<p>Rarely needed - for developer use. Set internal tree dumping level globally to a specific dumping level or set the specified Verilator source file to the specified tree dumping level (e.g. <code>--dump-treei-V3Order 9</code>). Level 0 disbles dumps and is equivalent to &quot;--no-dump-tree&quot;. Level 9 enables dumping of every stage.</p>

</dd>
<dt id="E">-E</dt>
<dd>

<p>Preprocess the source code, but do not compile, as with &#39;gcc -E&#39;. Output is written to standard out. Beware of enabling debugging messages, as they will also go to standard out.</p>

</dd>
<dt id="error-limit-value">--error-limit <i>value</i></dt>
<dd>

<p>After this number of errors or warnings are encountered, exit. Defaults to 50.</p>

</dd>
<dt id="exe">--exe</dt>
<dd>

<p>Generate an executable. You will also need to pass additional .cpp files on the command line that implement the main loop for your simulation.</p>

</dd>
<dt id="F-file">-F <i>file</i></dt>
<dd>

<p>Read the specified file, and act as if all text inside it was specified as command line parameters. Any relative paths are relative to the directory containing the specified file. See also -f. Note -F is fairly standard across Verilog tools.</p>

</dd>
<dt id="f-file">-f <i>file</i></dt>
<dd>

<p>Read the specified file, and act as if all text inside it was specified as command line parameters. Any relative paths are relative to the current directory. See also -F. Note -f is fairly standard across Verilog tools.</p>

<p>The file may contain // comments which are ignored to the end of the line. Any $VAR, $(VAR), or ${VAR} will be replaced with the specified environment variable.</p>

</dd>
<dt id="FI-file">-FI <i>file</i></dt>
<dd>

<p>Force include of the specified C++ header file. All generated C++ files will insert a #include of the specified file before any other includes. The specified file might be used to contain define prototypes of custom VL_VPRINTF functions, and may need to include verilatedos.h as this file is included before any other standard includes.</p>

</dd>
<dt id="Gname-value">-G<i>name</i>=<i>value</i></dt>
<dd>

<p>Overwrites the given parameter of the toplevel module. The value is limited to basic data literals:</p>

<dl>

<dt id="Verilog-integer-literals">Verilog integer literals</dt>
<dd>

<p>The standard verilog integer literals are supported, so values like 32&#39;h8, 2&#39;b00, 4 etc. are allowed. Care must be taken that the single quote (I&#39;) is properly escaped in an interactive shell, e.g., as -GWIDTH=8\&#39;hx.</p>

</dd>
<dt id="C-integer-literals">C integer literals</dt>
<dd>

<p>It is also possible to use C integer notation, including hexadecimal (0x..), octal (0..) or binary (0b..) notation.</p>

</dd>
<dt id="Double-literals">Double literals</dt>
<dd>

<p>Double literals must contain a dot (.) and/or an exponent (e).</p>

</dd>
<dt id="Strings">Strings</dt>
<dd>

<p>String must in double quotes (&quot;&quot;). On the command line it is required to escape them properly, e.g. as -GSTR=&quot;\&quot;My String\&quot;&quot; or -GSTR=&#39;&quot;My String&quot;&#39;.</p>

</dd>
</dl>

</dd>
<dt id="gate-stmts-value">--gate-stmts <i>value</i></dt>
<dd>

<p>Rarely needed. Set the maximum number of statements that may be present in an equation for the gate substitution optimization to inline that equation.</p>

</dd>
<dt id="gdb">--gdb</dt>
<dd>

<p>Run Verilator underneath an interactive GDB (or VERILATOR_GDB environment variable value) session. See also --gdbbt.</p>

</dd>
<dt id="gdbbt">--gdbbt</dt>
<dd>

<p>If --debug is specified, run Verilator underneath a GDB process and print a backtrace on exit, then exit GDB immediately. Without --debug or if GDB doesn&#39;t seem to work, this flag is ignored. Intended for easy creation of backtraces by users; otherwise see the --gdb flag.</p>

</dd>
<dt id="getenv-variable">--getenv <i>variable</i></dt>
<dd>

<p>If the variable is declared in the environment, print it and exit immediately. Otherwise, if it&#39;s built into Verilator (e.g. VERILATOR_ROOT), print that and exit immediately. Otherwise, print a newline and exit immediately. This can be useful in makefiles. See also -V, and the various *.mk files.</p>

</dd>
<dt id="help">--help</dt>
<dd>

<p>Displays this message and program version and exits.</p>

</dd>
<dt id="Idir">-I<i>dir</i></dt>
<dd>

<p>See -y.</p>

</dd>
<dt id="if-depth-value">--if-depth <i>value</i></dt>
<dd>

<p>Rarely needed. Set the depth at which the IFDEPTH warning will fire, defaults to 0 which disables this warning.</p>

</dd>
<dt id="incdir-dir">+incdir+<i>dir</i></dt>
<dd>

<p>See -y.</p>

</dd>
<dt id="inhibit-sim">--inhibit-sim</dt>
<dd>

<p>Rarely needed. Create a &quot;inhibitSim(bool)&quot; function to enable and disable evaluation. This allows an upper level testbench to disable modules that are not important in a given simulation, without needing to recompile or change the SystemC modules instantiated.</p>

</dd>
<dt id="inline-mult-value">--inline-mult <i>value</i></dt>
<dd>

<p>Tune the inlining of modules. The default value of 2000 specifies that up to 2000 new operations may be added to the model by inlining, if more than this number of operations would result, the module is not inlined. Larger values, or a value &lt; 1 will inline everything, will lead to longer compile times, but potentially faster runtimes. This setting is ignored for very small modules; they will always be inlined, if allowed.</p>

</dd>
<dt id="LDFLAGS-flags">-LDFLAGS <i>flags</i></dt>
<dd>

<p>Add specified C linker flags to the generated makefiles. For multiple flags either pass them as a single argument with space separators quoted in the shell (<code>-LDFLAGS &quot;-a -b&quot;</code>), or use multiple -LDFLAGS arguments (<code>-LDFLAGS -a -LDFLAGS -b</code>).</p>

<p>When make is run on the generated makefile these will be passed to the C++ linker (ld) *after* the primary file being linked. This flag is called -LDFLAGS as that&#39;s the traditional name in simulators; it&#39;s would have been better called LDLIBS as that&#39;s the Makefile variable it controls. (In Make, LDFLAGS is before the first object, LDLIBS after. -L libraries need to be in the Make variable LDLIBS, not LDFLAGS.)</p>

</dd>
<dt id="l2-name-value">--l2-name <i>value</i></dt>
<dd>

<p>Instead of using the module name when showing Verilog scope, use the name provided. This allows simplifying some Verilator-embedded modeling methodologies. Default is an l2-name matching the top module. The default before 3.884 was &quot;--l2-name v&quot;</p>

<p>For example, the program &quot;module t; initial $display(&quot;%m&quot;); endmodule&quot; will show by default &quot;t&quot;. With &quot;--l2-name v&quot; it will print &quot;v&quot;.</p>

</dd>
<dt id="language-value">--language <i>value</i></dt>
<dd>

<p>A synonym for <code>--default-language</code>, for compatibility with other tools and earlier versions of Verilator.</p>

</dd>
<dt id="libext-ext-ext">+libext+<i>ext</i>+<i>ext</i>...</dt>
<dd>

<p>Specify the extensions that should be used for finding modules. If for example module <i>x</i> is referenced, look in <i>x</i>.<i>ext</i>. Note +libext+ is fairly standard across Verilog tools. Defaults to .v and .sv.</p>

</dd>
<dt id="lint-only">--lint-only</dt>
<dd>

<p>Check the files for lint violations only, do not create any other output.</p>

<p>You may also want the -Wall option to enable messages that are considered stylistic and not enabled by default.</p>

<p>If the design is not to be completely Verilated see also the --bbox-sys and --bbox-unsup options.</p>

</dd>
<dt id="MMD">--MMD</dt>
<dd>

<p>Enable creation of .d dependency files, used for make dependency detection, similar to gcc -MMD option. On by default, use --no-MMD to disable.</p>

</dd>
<dt id="MP">--MP</dt>
<dd>

<p>When creating .d dependency files with --MMD, make phony targets. Similar to gcc -MP option.</p>

</dd>
<dt id="Mdir-directory">--Mdir <i>directory</i></dt>
<dd>

<p>Specifies the name of the Make object directory. All generated files will be placed in this directory. If not specified, &quot;obj_dir&quot; is used. The directory is created if it does not exist and the parent directories exist; otherwise manually create the Mdir before calling Verilator.</p>

</dd>
<dt id="mod-prefix-topname">--mod-prefix <i>topname</i></dt>
<dd>

<p>Specifies the name to prepend to all lower level classes. Defaults to the same as --prefix.</p>

</dd>
<dt id="no-clk-signal-name">--no-clk <i>signal-name</i></dt>
<dd>

<p>Prevent the specified signal from being marked as clock. See <code>--clk</code>.</p>

</dd>
<dt id="no-decoration">--no-decoration</dt>
<dd>

<p>When creating output Verilated code, minimize comments, whitespace, symbol names and other decorative items, at the cost of greatly reduced readability. This may assist C++ compile times. This will not typically change the ultimate model&#39;s performance, but may in some cases.</p>

</dd>
<dt id="no-pins64">--no-pins64</dt>
<dd>

<p>Backward compatible alias for &quot;--pins-bv 33&quot;.</p>

</dd>
<dt id="no-relative-cfuncs">--no-relative-cfuncs</dt>
<dd>

<p>Disable &#39;this-&gt;&#39; references in generated functions, and instead Verilator will generate absolute references starting from &#39;vlTOPp-&gt;&#39;. This prevents V3Combine from merging functions from multiple instances of the same module, so it can grow the instruction stream.</p>

<p>This is a work around for old compilers. Don&#39;t set this if your C++ compiler supports __restrict__ properly, as GCC 4.5.x and newer do. For older compilers, test if this switch gives you better performance or not.</p>

<p>Compilers which don&#39;t honor __restrict__ will suspect that &#39;this-&gt;&#39; references and &#39;vlTOPp-&gt;&#39; references may alias, and may write slow code with extra loads and stores to handle the (imaginary) aliasing. Using only &#39;vlTOPp-&gt;&#39; references allows these old compilers to produce tight code.</p>

</dd>
<dt id="no-skip-identical">--no-skip-identical</dt>
<dd>

<p>Rarely needed. Disables skipping execution of Verilator if all source files are identical, and all output files exist with newer dates.</p>

</dd>
<dt id="notimingchecks">+notimingchecks</dt>
<dd>

<p>Ignored for compatibility with other simulators.</p>

</dd>
<dt id="O0">-O0</dt>
<dd>

<p>Disables optimization of the model.</p>

</dd>
<dt id="O3">-O3</dt>
<dd>

<p>Enables slow optimizations for the code Verilator itself generates (as opposed to &quot;-CFLAGS -O3&quot; which effects the C compiler&#39;s optimization. -O3 may reduce simulation runtimes at the cost of compile time. This currently sets --inline-mult -1.</p>

</dd>
<dt id="Ooptimization-letter">-O<i>optimization-letter</i></dt>
<dd>

<p>Rarely needed. Enables or disables a specific optimizations, with the optimization selected based on the letter passed. A lowercase letter disables an optimization, an upper case letter enables it. This is intended for debugging use only; see the source code for version-dependent mappings of optimizations to -O letters.</p>

</dd>
<dt id="o-executable">-o <i>executable</i></dt>
<dd>

<p>Specify the name for the final executable built if using --exe. Defaults to the --prefix if not specified.</p>

</dd>
<dt id="no-order-clock-delay">--no-order-clock-delay</dt>
<dd>

<p>Rarely needed. Disables a bug fix for ordering of clock enables with delayed assignments. This flag should only be used when suggested by the developers.</p>

</dd>
<dt id="output-split-bytes">--output-split <i>bytes</i></dt>
<dd>

<p>Enables splitting the output .cpp files into multiple outputs. When a C++ file exceeds the specified number of operations, a new file will be created at the next function boundary. In addition, any slow routines will be placed into __Slow files. This accelerates compilation by as optimization can be disabled on the slow routines, and the remaining files can be compiled on parallel machines. Using --output-split should have only a trivial impact on performance. With GCC 3.3 on a 2GHz Opteron, --output-split 20000 will result in splitting into approximately one-minute-compile chunks.</p>

</dd>
<dt id="output-split-cfuncs-statements">--output-split-cfuncs <i>statements</i></dt>
<dd>

<p>Enables splitting functions in the output .cpp files into multiple functions. When a generated function exceeds the specified number of operations, a new function will be created. With --output-split, this will enable GCC to compile faster, at a small loss in performance that gets worse with decreasing split values. Note that this option is stronger than --output-split in the sense that --output-split will not split inside a function.</p>

</dd>
<dt id="output-split-ctrace-statements">--output-split-ctrace <i>statements</i></dt>
<dd>

<p>Enables splitting trace functions in the output .cpp files into multiple functions. Defaults to same setting as --output-split-cfuncs.</p>

</dd>
<dt id="P">-P</dt>
<dd>

<p>With -E, disable generation of `line markers and blank lines, similar to GCC -P flag.</p>

</dd>
<dt id="pins64">--pins64</dt>
<dd>

<p>Backward compatible alias for &quot;--pins-bv 65&quot;. Note that&#39;s a 65, not a 64.</p>

</dd>
<dt id="pins-bv-width">--pins-bv <i>width</i></dt>
<dd>

<p>Specifies SystemC inputs/outputs of greater than or equal to <i>width</i> bits wide should use sc_bv&#39;s instead of uint32/vluint64_t&#39;s. The default is &quot;--pins-bv 65&quot;, and the value must be less than or equal to 65. Versions before Verilator 3.671 defaulted to &quot;--pins-bv 33&quot;. The more sc_bv is used, the worse for performance. Use the &quot;/*verilator sc_bv*/&quot; attribute to select specific ports to be sc_bv.</p>

</dd>
<dt id="pins-sc-uint">--pins-sc-uint</dt>
<dd>

<p>Specifies SystemC inputs/outputs of greater than 2 bits wide should use sc_uint between 2 and 64. When combined with the &quot;--pins-sc-biguint&quot; combination, it results in sc_uint being used between 2 and 64 and sc_biguint being used between 65 and 512.</p>

</dd>
<dt id="pins-sc-biguint">--pins-sc-biguint</dt>
<dd>

<p>Specifies SystemC inputs/outputs of greater than 65 bits wide should use sc_biguint between 65 and 512, and sc_bv from 513 upwards. When combined with the &quot;--pins-sc-uint&quot; combination, it results in sc_uint being used between 2 and 64 and sc_biguint being used between 65 and 512.</p>

</dd>
<dt id="pins-uint8">--pins-uint8</dt>
<dd>

<p>Specifies SystemC inputs/outputs that are smaller than the --pins-bv setting and 8 bits or less should use uint8_t instead of uint32_t. Likewise pins of width 9-16 will use uint16_t instead of uint32_t.</p>

</dd>
<dt id="pipe-filter-command">--pipe-filter <i>command</i></dt>
<dd>

<p>Rarely needed and experimental. Verilator will spawn the specified command as a subprocess pipe, to allow the command to perform custom edits on the Verilog code before it reaches Verilator.</p>

<p>Before reading each Verilog file, Verilator will pass the file name to the subprocess&#39; stdin with &#39;read_verilog &quot;&lt;filename&gt;&quot;&#39;. The filter may then read the file and perform any filtering it desires, and feeds the new file contents back to Verilator on stdout with &#39;Content-Length&#39;. Output to stderr from the filter feeds through to Verilator&#39;s stdout and if the filter exits with non-zero status Verilator terminates. See the t/t_pipe_filter test for an example.</p>

<p>To debug the output of the filter, try using the -E option to see preprocessed output.</p>

</dd>
<dt id="pp-comments">--pp-comments</dt>
<dd>

<p>With -E, show comments in preprocessor output.</p>

</dd>
<dt id="prefix-topname">--prefix <i>topname</i></dt>
<dd>

<p>Specifies the name of the top level class and makefile. Defaults to V prepended to the name of the --top-module switch, or V prepended to the first Verilog filename passed on the command line.</p>

</dd>
<dt id="prof-cfuncs">--prof-cfuncs</dt>
<dd>

<p>Modify the created C++ functions to support profiling. The functions will be minimized to contain one &quot;basic&quot; statement, generally a single always block or wire statement. (Note this will slow down the executable by ~5%.) Furthermore, the function name will be suffixed with the basename of the Verilog module and line number the statement came from. This allows gprof or oprofile reports to be correlated with the original Verilog source statements. See also <a>verilator_profcfunc</a>.</p>

</dd>
<dt id="prof-threads">--prof-threads</dt>
<dd>

<p>Enable gantt chart data collection for threaded builds.</p>

<p>Verilator will record the start and end time of each macro-task across a number of calls to eval. (What is a macro-task? See the Verilator internals document.)</p>

<p>When profiling is enabled, the runtime will emit a blurb of profiling data in non-human-friendly form. The <code>verilator_gantt</code> script will transform this into a nicer visual format and produce some related statistics.</p>

</dd>
<dt id="private">--private</dt>
<dd>

<p>Opposite of --public. Is the default; this option exists for backwards compatibility.</p>

</dd>
<dt id="public">--public</dt>
<dd>

<p>This is only for historical debug use. Using it may result in mis-simulation of generated clocks.</p>

<p>Declares all signals and modules public. This will turn off signal optimizations as if all signals had a /*verilator public*/ comments and inlining. This will also turn off inlining as if all modules had a /*verilator public_module*/, unless the module specifically enabled it with /*verilator inline_module*/.</p>

</dd>
<dt id="pvalue-name-value">-pvalue+<i>name</i>=<i>value</i></dt>
<dd>

<p>Overwrites the given parameter(s) of the toplevel module. See -G for a detailed description.</p>

</dd>
<dt id="relative-includes">--relative-includes</dt>
<dd>

<p>When a file references an include file, resolve the filename relative to the path of the referencing file, instead of relative to the current directory.</p>

</dd>
<dt id="report-unoptflat">--report-unoptflat</dt>
<dd>

<p>Extra diagnostics for UNOPTFLAT warnings. This includes for each loop, the 10 widest variables in the loop, and the 10 most fanned out variables in the loop. These are candidates for splitting into multiple variables to break the loop.</p>

<p>In addition produces a GraphViz DOT file of the entire strongly connected components within the source associated with each loop. This is produced irrespective of whether --dump-tree is set. Such graphs may help in analyzing the problem, but can be very large indeed.</p>

<p>Various commands exist for viewing and manipulating DOT files. For example the <i>dot</i> command can be used to convert a DOT file to a PDF for printing. For example:</p>

<pre><code>    dot -Tpdf -O Vt_unoptflat_simple_2_35_unoptflat.dot</code></pre>

<p>will generate a PDF Vt_unoptflat_simple_2_35_unoptflat.dot.pdf from the DOT file.</p>

</dd>
<dt id="savable">--savable</dt>
<dd>

<p>Enable including save and restore functions in the generated model.</p>

<p>The user code must create a VerilatedSerialize or VerilatedDeserialze object then calling the &lt;&lt; or &gt;&gt; operators on the generated model and any other data the process needs saved/restored. These functions are not thread safe, and are typically called only by a main thread.</p>

<p>For example:</p>

<pre><code>    void save_model(const char* filenamep) {
        VerilatedSave os;
        os.open(filenamep);
        os &lt;&lt; main_time;  // user code must save the timestamp, etc
        os &lt;&lt; *topp;
    }
    void restore_model(const char* filenamep) {
        VerilatedRestore os;
        os.open(filenamep);
        os &gt;&gt; main_time;
        os &gt;&gt; *topp;
    }</code></pre>

</dd>
<dt id="sc">--sc</dt>
<dd>

<p>Specifies SystemC output mode; see also --cc.</p>

</dd>
<dt id="stats">--stats</dt>
<dd>

<p>Creates a dump file with statistics on the design in {prefix}__stats.txt.</p>

</dd>
<dt id="stats-vars">--stats-vars</dt>
<dd>

<p>Creates more detailed statistics, including a list of all the variables by size (plain --stats just gives a count). See --stats, which is implied by this.</p>

</dd>
<dt id="sv">-sv</dt>
<dd>

<p>Specifies SystemVerilog language features should be enabled; equivalent to &quot;--language 1800-2005&quot;. This option is selected by default, it exists for compatibility with other simulators.</p>

</dd>
<dt id="systemverilogext-ext">+systemverilogext+<i>ext</i></dt>
<dd>

<p>A synonym for <code>+1800-2017ext+</code><i>ext</i>.</p>

</dd>
<dt id="threads-threads">--threads <i>threads</i></dt>
<dd>

</dd>
<dt id="no-threads">--no-threads</dt>
<dd>

<p>With --threads 0 or --no-threads, the default, the generated model is not thread safe. With --threads 1, the generated model is single threaded but may run in a multithreaded environment. With --threads N, where N &gt;= 2, the model is generated to run multithreaded on up to N threads. See <a href="#MULTITHREADING">&quot;MULTITHREADING&quot;</a>.</p>

</dd>
<dt id="threads-dpi-all">--threads-dpi all</dt>
<dd>

</dd>
<dt id="threads-dpi-none">--threads-dpi none</dt>
<dd>

</dd>
<dt id="threads-dpi-pure">--threads-dpi pure</dt>
<dd>

<p>When using --dpi with --threads, control what DPI tasks are thread safe.</p>

<p>With --threads-dpi all, enable Verilator to assume all DPI imports are threadsafe, and to use thread-local storage for communication with DPI, potentially improving performance. Any DPI libraries need appropriate mutexes to avoid undefined behavior.</p>

<p>With --threads-dpi none, Verilator assume DPI imports are not thread safe, and Verilator will serialize calls to DPI imports by default, potentially harming performance.</p>

<p>With --threads-dpi pure, the default, Verilator assumes DPI pure imports are threadsafe, but non-pure DPI imports are not.</p>

</dd>
<dt id="threads-max-mtasks-value">--threads-max-mtasks <i>value</i></dt>
<dd>

<p>Rarely needed. When using --threads, specify the number of mtasks the model is to be partitioned into. If unspecified, Verilator approximates a good value.</p>

</dd>
<dt id="top-module-topname">--top-module <i>topname</i></dt>
<dd>

<p>When the input Verilog contains more than one top level module, specifies the name of the top level Verilog module to become the top, and sets the default for if --prefix is not used. This is not needed with standard designs with only one top.</p>

</dd>
<dt id="trace">--trace</dt>
<dd>

<p>Adds waveform tracing code to the model using VCD format. This overrides <code>--trace-fst</code>.</p>

<p>Verilator will generate additional {prefix}__Trace*.cpp files that will need to be compiled. In addition verilated_vcd_sc.cpp (for SystemC traces) or verilated_vcd_c.cpp (for both) must be compiled and linked in. If using the Verilator generated Makefiles, these files will be added as source targets for you. If you&#39;re not using the Verilator makefiles, you will need to add these to your Makefile manually.</p>

<p>Having tracing compiled in may result in some small performance losses, even when waveforms are not turned on during model execution.</p>

</dd>
<dt id="trace-fst">--trace-fst</dt>
<dd>

<p>Enable FST waveform tracing in the model. This overrides <code>--trace</code> and <code>--trace-fst-thread</code>. See also <code>--trace-fst-thread</code>.</p>

</dd>
<dt id="trace-fst-thread">--trace-fst-thread</dt>
<dd>

<p>Enable FST waveform tracing in the model, using a separate thread. This is typically faster in runtime but slower in total computes than <code>--trace-fst</code>. This overrides <code>--trace</code> and <code>--trace-fst</code>.</p>

</dd>
<dt id="trace-depth-levels">--trace-depth <i>levels</i></dt>
<dd>

<p>Specify the number of levels deep to enable tracing, for example --trace-level 1 to only see the top level&#39;s signals. Defaults to the entire model. Using a small number will decrease visibility, but greatly improve runtime and trace file size.</p>

</dd>
<dt id="trace-max-array-depth">--trace-max-array <i>depth</i></dt>
<dd>

<p>Rarely needed. Specify the maximum array depth of a signal that may be traced. Defaults to 32, as tracing large arrays may greatly slow traced simulations.</p>

</dd>
<dt id="trace-max-width-width">--trace-max-width <i>width</i></dt>
<dd>

<p>Rarely needed. Specify the maximum bit width of a signal that may be traced. Defaults to 256, as tracing large vectors may greatly slow traced simulations.</p>

</dd>
<dt id="no-trace-params">--no-trace-params</dt>
<dd>

<p>Disable tracing of parameters.</p>

</dd>
<dt id="trace-structs">--trace-structs</dt>
<dd>

<p>Enable tracing to show the name of packed structure, union, and packed array fields, rather than a simgle combined packed bus. Due to VCD file format constraints this may result in significantly slower trace times and larger trace files.</p>

</dd>
<dt id="trace-underscore">--trace-underscore</dt>
<dd>

<p>Enable tracing of signals that start with an underscore. Normally, these signals are not output during tracing. See also --coverage-underscore.</p>

</dd>
<dt id="Uvar">-U<i>var</i></dt>
<dd>

<p>Undefines the given preprocessor symbol.</p>

</dd>
<dt id="unroll-count-loops">--unroll-count <i>loops</i></dt>
<dd>

<p>Rarely needed. Specifies the maximum number of loop iterations that may be unrolled. See also BLKLOOPINIT warning.</p>

</dd>
<dt id="unroll-stmts-statements">--unroll-stmts <i>statements</i></dt>
<dd>

<p>Rarely needed. Specifies the maximum number of statements in a loop for that loop to be unrolled. See also BLKLOOPINIT warning.</p>

</dd>
<dt id="unused-regexp-regexp">--unused-regexp <i>regexp</i></dt>
<dd>

<p>Rarely needed. Specifies a simple regexp with * and ? that if a signal name matches will suppress the UNUSED warning. Defaults to &quot;*unused*&quot;. Setting it to &quot;&quot; disables matching.</p>

</dd>
<dt id="V">-V</dt>
<dd>

<p>Shows the verbose version, including configuration information compiled into Verilator. (Similar to perl -V.) See also --getenv.</p>

</dd>
<dt id="v-filename">-v <i>filename</i></dt>
<dd>

<p>Read the filename as a Verilog library. Any modules in the file may be used to resolve cell instantiations in the top level module, else ignored. Note -v is fairly standard across Verilog tools.</p>

</dd>
<dt id="verilog1995ext-ext">+verilog1995ext+<i>ext</i></dt>
<dd>

</dd>
<dt id="verilog2001ext-ext">+verilog2001ext+<i>ext</i></dt>
<dd>

<p>Synonyms for <code>+1364-1995ext+</code><i>ext</i> and <code>+1364-2001ext+</code><i>ext</i> respectively</p>

</dd>
<dt id="version">--version</dt>
<dd>

<p>Displays program version and exits.</p>

</dd>
<dt id="vpi">--vpi</dt>
<dd>

<p>Enable use of VPI and linking against the verilated_vpi.cpp files.</p>

</dd>
<dt id="Wall">-Wall</dt>
<dd>

<p>Enable all code style warnings, including code style warnings that are normally disabled by default. Equivelent to &quot;-Wwarn-lint -Wwarn-style&quot;. Excludes some specialty warnings, i.e. IMPERFECTSCH.</p>

</dd>
<dt id="Werror-message">-Werror-<i>message</i></dt>
<dd>

<p>Convert the specified warning message into an error message. This is generally to discourage users from violating important site-wide rules, for example <code>-Werror-NOUNOPTFLAT</code>.</p>

</dd>
<dt id="Wfuture-message">-Wfuture-<i>message</i></dt>
<dd>

<p>Rarely needed. Suppress unknown Verilator comments or warning messages with the given message code. This is used to allow code written with pragmas for a later version of Verilator to run under a older version; add -Wfuture- arguments for each message code or comment that the new version supports which the older version does not support.</p>

</dd>
<dt id="Wno-message">-Wno-<i>message</i></dt>
<dd>

<p>Disable the specified warning message, or in some cases where noted here disable an error. This will override any lint_on directives in the source, i.e. the warning will still not be printed.</p>

</dd>
<dt id="Wno-lint">-Wno-lint</dt>
<dd>

<p>Disable all lint related warning messages, and all style warnings. This is equivalent to &quot;-Wno-ALWCOMBORDER -Wno-BSSPACE -Wno-CASEINCOMPLETE -Wno-CASEOVERLAP -Wno-CASEX -Wno-CASEWITHX -Wno-CMPCONST -Wno-COLONPLUS -Wno-ENDLABEL -Wno-IMPLICIT -Wno-LITENDIAN -Wno-PINCONNECTEMPTY -Wno-PINMISSING -Wno-SYNCASYNCNET -Wno-UNDRIVEN -Wno-UNSIGNED -Wno-UNUSED -Wno-WIDTH&quot; plus the list shown for Wno-style.</p>

<p>It is strongly recommended you cleanup your code rather than using this option, it is only intended to be use when running test-cases of code received from third parties.</p>

</dd>
<dt id="Wno-style">-Wno-style</dt>
<dd>

<p>Disable all code style related warning messages (note by default they are already disabled). This is equivalent to &quot;-Wno-DECLFILENAME -Wno-DEFPARAM -Wno-IMPORTSTAR -Wno-INCABSPATH -Wno-PINCONNECTEMPTY -Wno-PINNOCONNECT -Wno-SYNCASYNCNET -Wno-UNDRIVEN -Wno-UNUSED -Wno-VARHIDDEN&quot;.</p>

</dd>
<dt id="Wno-fatal">-Wno-fatal</dt>
<dd>

<p>When warnings are detected, print them, but do not exit the simulator.</p>

<p>Having warning messages in builds is sloppy. It is strongly recommended you cleanup your code, use inline lint_off, or use -Wno-... flags rather than using this option.</p>

</dd>
<dt id="Wwarn-message">-Wwarn-<i>message</i></dt>
<dd>

<p>Enables the specified warning message.</p>

</dd>
<dt id="Wwarn-lint">-Wwarn-lint</dt>
<dd>

<p>Enable all lint related warning messages (note by default they are already enabled), but do not affect style messages. This is equivalent to &quot;-Wwarn-ALWCOMBORDER -Wwarn-BSSPACE -Wwarn-CASEINCOMPLETE -Wwarn-CASEOVERLAP -Wwarn-CASEX -Wwarn-CASEWITHX -Wwarn-CMPCONST -Wwarn-COLONPLUS -Wwarn-ENDLABEL -Wwarn-IMPLICIT -Wwarn-LITENDIAN -Wwarn-PINMISSING -Wwarn-REALCVT -Wwarn-UNSIGNED -Wwarn-WIDTH&quot;.</p>

</dd>
<dt id="Wwarn-style">-Wwarn-style</dt>
<dd>

<p>Enable all code style related warning messages. This is equivalent to &quot;-Wwarn ASSIGNDLY -Wwarn-DECLFILENAME -Wwarn-DEFPARAM -Wwarn-INCABSPATH -Wwarn-PINNOCONNECT -Wwarn-SYNCASYNCNET -Wwarn-UNDRIVEN -Wwarn-UNUSED -Wwarn-VARHIDDEN&quot;.</p>

</dd>
<dt id="x-assign-0">--x-assign 0</dt>
<dd>

</dd>
<dt id="x-assign-1">--x-assign 1</dt>
<dd>

</dd>
<dt id="x-assign-fast-default">--x-assign fast (default)</dt>
<dd>

</dd>
<dt id="x-assign-unique">--x-assign unique</dt>
<dd>

<p>Controls the two-state value that is replaced when an assignment to X is encountered. <code>--x-assign fast</code>, the default, converts all Xs to whatever is best for performance. <code>--x-assign 0</code> converts all Xs to 0s, and is also fast. <code>--x-assign 1</code> converts all Xs to 1s, this is nearly as fast as 0, but more likely to find reset bugs as active high logic will fire. <code>--x-assign unique</code> will call a function to determine the value, this allows randomization of all Xs to find reset bugs and is the slowest, but safest for finding reset bugs in code.</p>

<p>If using --x-assign unique, you may want to seed your random number generator such that each regression run gets a different randomization sequence. Use the system&#39;s srand48() or for Windows srand() function to do this. You&#39;ll probably also want to print any seeds selected, and code to enable rerunning with that same seed so you can reproduce bugs.</p>

<p><b>Note.</b> This option applies only to variables which are explicitly assigned to X in the Verilog source code. Initial values of clocks are set to 0 unless --x-initial-edge is specified. Initial values of all other state holding variables are controlled with --x-initial.</p>

</dd>
<dt id="x-initial-0">--x-initial 0</dt>
<dd>

</dd>
<dt id="x-initial-fast">--x-initial fast</dt>
<dd>

</dd>
<dt id="x-initial-unique-default">--x-initial unique (default)</dt>
<dd>

<p>Controls the two-state value that is used to initialize variables that are not otherwise initialized.</p>

<p><code>--x-initial 0</code>, initializes all otherwise uninitialized variables to zero.</p>

<p><code>--x-initial unique</code>, the default, initializes variables using a function, which determines the value to use each initialization. This gives greatest flexibility and allows finding reset bugs. See <a href="#Unknown-states">&quot;Unknown states&quot;</a>.</p>

<p><code>--x-initial fast</code>, is best for performance, and initializes all variables to a state Verilator determines is optimal. This may allow further code optimizations, but will likely hide any code bugs relating to missing resets.</p>

<p><b>Note.</b> This option applies only to initial values of variables. Initial values of clocks are set to 0 unless --x-initial-edge is specified.</p>

</dd>
<dt id="x-initial-edge">--x-initial-edge</dt>
<dd>

<p>Enables emulation of event driven simulators which generally trigger an edge on a transition from X to 1 (<code>posedge</code>) or X to 0 (<code>negedge</code>). Thus the following code, where <code>rst_n</code> is uninitialized would set <code>res_n</code> to <code>1&#39;b1</code> when <code>rst_n</code> is first set to zero:</p>

<pre><code>    reg  res_n = 1&#39;b0;

    always @(negedge rst_n) begin
       if (rst_n == 1&#39;b0) begin
          res_n &lt;= 1&#39;b1;
       end
    end</code></pre>

<p>In Verilator, by default, uninitialized clocks are given a value of zero, so the above <code>always</code> block would not trigger.</p>

<p>While it is not good practice, there are some designs that rely on X &rarr; 0 triggering a <code>negedge</code>, particularly in reset sequences. Using --x-initial-edge with Verilator will replicate this behavior. It will also ensure that X &rarr; 1 triggers a <code>posedge</code>.</p>

<p><b>Note.</b> Some users have reported that using this option can affect convergence, and that it may be necessary to use --converge-limit to increase the number of convergence iterations. This may be another indication of problems with the modelled design that should be addressed.</p>

</dd>
<dt id="xml-only">--xml-only</dt>
<dd>

<p>Create XML output only, do not create any other output.</p>

<p>The XML format is intended to be used to leverage Verilator&#39;s parser and elaboration to feed to other downstream tools. Be aware that the XML format is still evolving; there will be some changes in future versions.</p>

</dd>
<dt id="y-dir">-y <i>dir</i></dt>
<dd>

<p>Add the directory to the list of directories that should be searched for include files or libraries. The three flags -y, +incdir and -I have similar effect; +incdir and +y are fairly standard across Verilog tools while -I is an alias for GCC compatibility.</p>

<p>Verilator defaults to the current directory (&quot;-y .&quot;) and any specified --Mdir, though these default paths are used after any user specified directories. This allows &#39;-y &quot;$(pwd)&quot;&#39; to be used if absolute filenames are desired for error messages instead of relative filenames.</p>

</dd>
</dl>

<h1 id="RUNTIME-ARGUMENTS">RUNTIME ARGUMENTS</h1>

<p>The following are the arguments that may be passed to a Verilated executable, provided that executable calls Verilated::commandArgs().</p>

<p>All runtime arguments begin with +verilator, so that the user&#39;s executable may skip over all +verilator arguments when parsing its command line.</p>

<dl>

<dt id="verilator-debug">+verilator+debug</dt>
<dd>

<p>Enable debugging. Equivalent to +verilator+debugi+4.</p>

</dd>
<dt id="verilator-debugi-value">+verilator+debugi+<i>value</i></dt>
<dd>

<p>Enable debugging at the provided level.</p>

</dd>
<dt id="verilator-help">+verilator+help</dt>
<dd>

<p>Display help and exit.</p>

</dd>
<dt id="verilator-prof-threads-file-filename">+verilator+prof+threads+file+<i>filename</i></dt>
<dd>

<p>When using --prof-threads, the filename to dump to. Defaults to &quot;profile_threads.dat&quot;.</p>

</dd>
<dt id="verilator-prof-threads-start-value">+verilator+prof+threads+start+<i>value</i></dt>
<dd>

<p>When using --prof-threads, Verilator will wait until $time is at this value, then start the profiling warmup, then capturing. Generally this should be set to some time that is well within the normal operation of the simulation, i.e. outside of reset. If 0, the dump is disabled. Defaults to 1.</p>

</dd>
<dt id="verilator-prof-threads-window-value">+verilator+prof+threads+window+<i>value</i></dt>
<dd>

<p>When using --prof-threads, after $time reaches +verilator+prof+threads+start, Verilator will warm up the profiling for this number of eval() calls, then will capture the profiling of this number of eval() calls. Defaults to 2, which makes sense for a single-clock-domain module where it&#39;s typical to want to capture one posedge eval() and one negedge eval().</p>

</dd>
<dt id="verilator-rand-reset-value">+verilator+rand+reset+<i>value</i></dt>
<dd>

<p>When a model was Verilated using &quot;-x-inital unique&quot;, sets the initialization technique. 0 = Reset to zeros. 1 = Reset to all-ones. 2 = Randomize. See <a href="#Unknown-states">&quot;Unknown states&quot;</a>.</p>

</dd>
<dt id="verilator-seed-value">+verilator+seed+<i>value</i></dt>
<dd>

<p>For $random and &quot;-x-initial unique&quot;, set the random seed value. If zero or not specified picks a value from the system random number generator.</p>

</dd>
<dt id="verilator-V">+verilator+V</dt>
<dd>

<p>Shows the verbose version, including configuration information.</p>

</dd>
<dt id="verilator-version">+verilator+version</dt>
<dd>

<p>Displays program version and exits.</p>

</dd>
</dl>

<h1 id="EXAMPLE-C-EXECUTION">EXAMPLE C++ EXECUTION</h1>

<p>We&#39;ll compile this example into C++.</p>

<pre><code>    mkdir test_our
    cd test_our

    cat &lt;&lt;EOF &gt;our.v
      module our;
         initial begin $display(&quot;Hello World&quot;); $finish; end
      endmodule
    EOF

    cat &lt;&lt;EOF &gt;sim_main.cpp
      #include &quot;Vour.h&quot;
      #include &quot;verilated.h&quot;
      int main(int argc, char** argv, char** env) {
          Verilated::commandArgs(argc, argv);
          Vour* top = new Vour;
          while (!Verilated::gotFinish()) { top-&gt;eval(); }
          delete top;
          exit(0);
      }
    EOF</code></pre>

<p>See the README in the source kit for various ways to install or point to Verilator binaries. In brief, if you are running Verilator that came from your operating system (as an RPM), or did a &quot;make install&quot; to place Verilator into your default path, you do not need anything special in your environment, and should not have VERILATOR_ROOT set. However, if you installed Verilator from sources and want to run Verilator out of where you compiled Verilator, you need to point to the kit:</p>

<pre><code>    # See above; don&#39;t do this if using an OS-distributed Verilator
    export VERILATOR_ROOT=/path/to/where/verilator/was/installed
    export PATH=$VERILATOR_ROOT/bin:$PATH</code></pre>

<p>Now we run Verilator on our little example.</p>

<pre><code>    verilator -Wall --cc our.v --exe sim_main.cpp</code></pre>

<p>We can see the source code under the &quot;obj_dir&quot; directory. See the FILES section below for descriptions of some of the files that were created.</p>

<pre><code>    ls -l obj_dir</code></pre>

<p>We then can compile it</p>

<pre><code>    make -j -C obj_dir -f Vour.mk Vour</code></pre>

<p>(Verilator included a default compile rule and link rule, since we used --exe and passed a .cpp file on the Verilator command line. You can also write your own compile rules, as we&#39;ll show in the SYSTEMC section.)</p>

<p>And now we run it</p>

<pre><code>    obj_dir/Vour</code></pre>

<p>And we get as output</p>

<pre><code>    Hello World
    - our.v:2: Verilog $finish</code></pre>

<p>Really, you&#39;re better off writing a Makefile to do all this for you. Then, when your source changes it will automatically run all of these steps; to aid this Verilator can create a makefile dependency file. See the examples directory in the distribution.</p>

<h1 id="EXAMPLE-SYSTEMC-EXECUTION">EXAMPLE SYSTEMC EXECUTION</h1>

<p>This is an example similar to the above, but using SystemC.</p>

<pre><code>    mkdir test_our_sc
    cd test_our_sc

    cat &lt;&lt;EOF &gt;our.v
      module our (clk);
         input clk;  // Clock is required to get initial activation
         always @ (posedge clk)
            begin $display(&quot;Hello World&quot;); $finish; end
      endmodule
    EOF

    cat &lt;&lt;EOF &gt;sc_main.cpp
      #include &quot;Vour.h&quot;
      int sc_main(int argc, char **argv) {
          Verilated::commandArgs(argc, argv);
          sc_clock clk (&quot;clk&quot;, 10, 0.5, 3, true);
          Vour* top;
          top = new Vour(&quot;top&quot;);
          top-&gt;clk(clk);
          while (!Verilated::gotFinish()) { sc_start(1, SC_NS); }
          delete top;
          exit(0);
      }
    EOF</code></pre>

<p>See the README in the source kit for various ways to install or point to Verilator binaries. In brief, if you are running Verilator that came from your operating system (as an RPM), or did a &quot;make install&quot; to place Verilator into your default path, you do not need anything special in your environment, and should not have VERILATOR_ROOT set. However, if you installed Verilator from sources and want to run Verilator out of where you compiled Verilator, you need to point to the kit:</p>

<pre><code>    # See above; don&#39;t do this if using an OS-distributed Verilator
    export VERILATOR_ROOT=/path/to/where/verilator/was/installed
    export PATH=$VERILATOR_ROOT/bin:$PATH</code></pre>

<p>Now we run Verilator on our little example.</p>

<pre><code>    verilator -Wall --sc our.v</code></pre>

<p>We then can compile it</p>

<pre><code>    cd obj_dir
    make -j -f Vour.mk Vour__ALL.a
    make -j -f Vour.mk ../sc_main.o verilated.o</code></pre>

<p>And link with SystemC. Note your path to the libraries may vary, depending on the operating system.</p>

<pre><code>    export SYSTEMC_LIBDIR=/path/to/where/libsystemc.a/exists
    export LD_LIBRARY_PATH=$SYSTEMC_LIBDIR:$LD_LIBRARY_PATH
    # Might be needed if SystemC 2.3.0
    export SYSTEMC_CXX_FLAGS=-pthread

    g++ -L$SYSTEMC_LIBDIR ../sc_main.o Vour__ALL*.o verilated.o \
              -o Vour -lsystemc</code></pre>

<p>And now we run it</p>

<pre><code>    cd ..
    obj_dir/Vour</code></pre>

<p>And we get the same output as the C++ example:</p>

<pre><code>    Hello World
    - our.v:2: Verilog $finish</code></pre>

<p>Really, you&#39;re better off using a Makefile to do all this for you. Then, when your source changes it will automatically run all of these steps. See the examples directory in the distribution.</p>

<h1 id="BENCHMARKING-OPTIMIZATION">BENCHMARKING &amp; OPTIMIZATION</h1>

<p>For best performance, run Verilator with the &quot;-O3 --x-assign=fast --x-initial fast --noassert&quot; flags. The -O3 flag will require longer compile times, and &quot;--x-assign fast --x-initial fast&quot; may increase the risk of reset bugs in trade for performance; see the above documentation for these flags.</p>

<p>If using Verilated multithreaded, use <code>numactl</code> to ensure you are using non-conflicting hardware resources. See <a href="#MULTITHREADING">&quot;MULTITHREADING&quot;</a>.</p>

<p>Minor Verilog code changes can also give big wins. You should not have any UNOPTFLAT warnings from Verilator. Fixing these warnings can result in huge improvements; one user fixed their one UNOPTFLAT warning by making a simple change to a clock latch used to gate clocks and gained a 60% performance improvement.</p>

<p>Beyond that, the performance of a Verilated model depends mostly on your C++ compiler and size of your CPU&#39;s caches.</p>

<p>By default, the lib/verilated.mk file has optimization turned off. This is for the benefit of new users, as it improves compile times at the cost of runtimes. To add optimization as the default, set one of three variables, OPT, OPT_FAST, or OPT_SLOW lib/verilated.mk. Or, use the -CFLAGS and/or -LDFLAGS option on the verilator command line to pass the flags directly to the compiler or linker. Or, just for one run, pass them on the command line to make:</p>

<pre><code>    make OPT_FAST=&quot;-O2 -fno-stack-protector&quot; -f Vour.mk Vour__ALL.a</code></pre>

<p>OPT_FAST specifies optimizations for those programs that are part of the fast path, mostly code that is executed every cycle. OPT_SLOW specifies optimizations for slow-path files (plus tracing), which execute only rarely, yet take a long time to compile with optimization on. OPT specifies overall optimization and affects all compiles, including those OPT_FAST and OPT_SLOW control. For best results, use OPT=&quot;-O2&quot;, and link with &quot;-static&quot;. Nearly the same results can be had with much better compile times with OPT_FAST=&quot;-O1 -fstrict-aliasing&quot;. Higher optimization such as &quot;-O3&quot; may help, but gcc compile times may be excessive under O3 on even medium sized designs. Alternatively, some larger designs report better performance using &quot;-Os&quot;.</p>

<p>Unfortunately, using the optimizer with SystemC files can result in compiles taking several minutes. (The SystemC libraries have many little inlined functions that drive the compiler nuts.)</p>

<p>For best results, use GCC 3.3 or newer. GCC 3.2 and earlier have optimization bugs around pointer aliasing detection, which can result in 2x performance losses.</p>

<p>If you will be running many simulations on a single compile, investigate feedback driven compilation. With GCC, using -fprofile-arcs, then -fbranch-probabilities will yield another 15% or so.</p>

<p>Modern compilers also support link-time optimization (LTO), which can help especially if you link in DPI code. To enable LTO on GCC, pass &quot;-flto&quot; in both compilation and link. Note LTO may cause excessive compile times on large designs.</p>

<p>If you are using your own makefiles, you may want to compile the Verilated code with -DVL_INLINE_OPT=inline. This will inline functions, however this requires that all cpp files be compiled in a single compiler run.</p>

<p>You may uncover further tuning possibilities by profiling the Verilog code. Use Verilator&#39;s --prof-cfuncs, then GCC&#39;s -g -pg. You can then run either oprofile or gprof to see where in the C++ code the time is spent. Run the gprof output through verilator_profcfunc and it will tell you what Verilog line numbers on which most of the time is being spent.</p>

<p>When done, please let the author know the results. I like to keep tabs on how Verilator compares, and may be able to suggest additional improvements.</p>

<h1 id="FILES">FILES</h1>

<p>All output files are placed in the output directory name specified with the -Mdir option, or &quot;obj_dir&quot; if not specified.</p>

<p>Verilator creates the following files in the output directory:</p>

<pre><code>    {prefix}.mk                         // Make include file for compiling
    {prefix}_classes.mk                 // Make include file with class names</code></pre>

<p>For -cc and -sc mode, it also creates:</p>

<pre><code>    {prefix}.cpp                        // Top level C++ file
    {prefix}.h                          // Top level header
    {prefix}__Slow{__n}.cpp             // Constructors and infrequent routines
    {prefix}{__n}.cpp                   // Additional top C++ files (--output-split)
    {prefix}{each_verilog_module}.cpp   // Lower level internal C++ files
    {prefix}{each_verilog_module}.h     // Lower level internal header files
    {prefix}{each_verilog_module}{__n}.cpp   // Additional lower C++ files (--output-split)</code></pre>

<p>In certain debug and other modes, it also creates:</p>

<pre><code>    {prefix}.xml                        // XML tree information (--xml)
    {prefix}__Dpi.cpp                   // DPI import and export wrappers
    {prefix}__Dpi.h                     // DPI import and export declarations
    {prefix}__Inlines.h                 // Inline support functions
    {prefix}__Syms.cpp                  // Global symbol table C++
    {prefix}__Syms.h                    // Global symbol table header
    {prefix}__Trace__Slow{__n}.cpp      // Wave file generation code (--trace)
    {prefix}__Trace{__n}.cpp            // Wave file generation code (--trace)
    {prefix}__cdc.txt                   // Clock Domain Crossing checks (--cdc)
    {prefix}__stats.txt                 // Statistics (--stats)</code></pre>

<p>It also creates internal files that can be mostly ignored:</p>

<pre><code>    {mod_prefix}_{each_verilog_module}{__n}.vpp  // Post-processed verilog
    {prefix}__ver.d                     // Make dependencies (-MMD)
    {prefix}__verFiles.dat              // Timestamps for skip-identical
    {prefix}{misc}.dot                  // Debugging graph files (--debug)
    {prefix}{misc}.tree                 // Debugging files (--debug)</code></pre>

<p>After running Make, the C++ compiler may produce the following:</p>

<pre><code>    verilated{misc}.d                   // Intermediate dependencies
    verilated{misc}.o                   // Intermediate objects
    {mod_prefix}{misc}.d                // Intermediate dependencies
    {mod_prefix}{misc}.o                // Intermediate objects
    {prefix}                            // Final executable (w/--exe argument)
    {prefix}__ALL.a                     // Library of all Verilated objects
    {prefix}__ALLboth.cpp               // Include of classes for single compile
    {prefix}__ALLcls.cpp                // Include of user classes for single compile
    {prefix}__ALLsup.cpp                // Include of support files for single compile
    {prefix}{misc}.d                    // Intermediate dependencies
    {prefix}{misc}.o                    // Intermediate objects</code></pre>

<h1 id="ENVIRONMENT">ENVIRONMENT</h1>

<dl>

<dt id="LD_LIBRARY_PATH">LD_LIBRARY_PATH</dt>
<dd>

<p>A generic Linux/OS variable specifying what directories have shared object (.so) files. This path should include SystemC and any other shared objects needed at runtime.</p>

</dd>
<dt id="OBJCACHE">OBJCACHE</dt>
<dd>

<p>Optionally specifies a caching or distribution program to place in front of all runs of the C++ Compiler. For example, &quot;objcache --read --write&quot;, or &quot;ccache&quot;. If using distcc or icecc/icecream, they would generally be run under either objcache or ccache; see the documentation for those programs.</p>

</dd>
<dt id="SYSTEMC">SYSTEMC</dt>
<dd>

<p>Deprecated. Used only if SYSTEMC_INCLUDE or SYSTEMC_LIBDIR is not set. If set, specifies the directory containing the SystemC distribution. If not specified, it will come from a default optionally specified at configure time (before Verilator was compiled).</p>

</dd>
<dt id="SYSTEMC_ARCH">SYSTEMC_ARCH</dt>
<dd>

<p>Deprecated. Used only if SYSTEMC_LIBDIR is not set. Specifies the architecture name used by the SystemC kit. This is the part after the dash in the lib-{...} directory name created by a &#39;make&#39; in the SystemC distribution. If not set, Verilator will try to intuit the proper setting, or use the default optionally specified at configure time (before Verilator was compiled).</p>

</dd>
<dt id="SYSTEMC_CXX_FLAGS">SYSTEMC_CXX_FLAGS</dt>
<dd>

<p>Specifies additional flags that are required to be passed to GCC when building the SystemC model. System 2.3.0 may need this set to &quot;-pthread&quot;.</p>

</dd>
<dt id="SYSTEMC_INCLUDE">SYSTEMC_INCLUDE</dt>
<dd>

<p>If set, specifies the directory containing the systemc.h header file. If not specified, it will come from a default optionally specified at configure time (before Verilator was compiled), or computed from SYSTEMC/include.</p>

</dd>
<dt id="SYSTEMC_LIBDIR">SYSTEMC_LIBDIR</dt>
<dd>

<p>If set, specifies the directory containing the libsystemc.a library. If not specified, it will come from a default optionally specified at configure time (before Verilator was compiled), or computed from SYSTEMC/lib-SYSTEMC_ARCH.</p>

</dd>
<dt id="VCS_HOME">VCS_HOME</dt>
<dd>

<p>If set, specifies the directory containing the Synopsys VCS distribution. When set, a &#39;make test&#39; in the Verilator distribution will also run VCS baseline regression tests.</p>

</dd>
<dt id="VERILATOR_BIN">VERILATOR_BIN</dt>
<dd>

<p>If set, specifies an alternative name of the Verilator binary. May be used for debugging and selecting between multiple operating system builds.</p>

</dd>
<dt id="VERILATOR_GDB">VERILATOR_GDB</dt>
<dd>

<p>If set, the command to run when using the --gdb option, such as &quot;ddd&quot;. If not specified, it will use &quot;gdb&quot;.</p>

</dd>
<dt id="VERILATOR_ROOT">VERILATOR_ROOT</dt>
<dd>

<p>Specifies the directory containing the distribution kit. This is used to find the executable, Perl library, and include files. If not specified, it will come from a default optionally specified at configure time (before Verilator was compiled). It should not be specified if using a pre-compiled Verilator RPM as the hardcoded value should be correct.</p>

</dd>
</dl>

<h1 id="CONNECTING-TO-C">CONNECTING TO C++</h1>

<p>Verilator creates a .h and .cpp file for the top level module and all modules under it. See the examples directory in the kit for examples.</p>

<p>After the modules are completed, there will be a <i>module</i>.mk file that may be used with Make to produce a <i>module</i>__ALL.a file with all required objects in it. This is then linked with the user&#39;s top level to create the simulation executable.</p>

<p>The user must write the top level of the simulation. Here&#39;s a simple example:</p>

<pre><code>        #include &lt;verilated.h&gt;          // Defines common routines
        #include &lt;iostream&gt;             // Need std::cout
        #include &quot;Vtop.h&quot;               // From Verilating &quot;top.v&quot;

        Vtop *top;                      // Instantiation of module

        vluint64_t main_time = 0;       // Current simulation time
        // This is a 64-bit integer to reduce wrap over issues and
        // allow modulus.  You can also use a double, if you wish.

        double sc_time_stamp () {       // Called by $time in Verilog
            return main_time;           // converts to double, to match
                                        // what SystemC does
        }

        int main(int argc, char** argv) {
            Verilated::commandArgs(argc, argv);   // Remember args

            top = new Vtop;             // Create instance

            top-&gt;reset_l = 0;           // Set some inputs

            while (!Verilated::gotFinish()) {
                if (main_time &gt; 10) {
                    top-&gt;reset_l = 1;   // Deassert reset
                }
                if ((main_time % 10) == 1) {
                    top-&gt;clk = 1;       // Toggle clock
                }
                if ((main_time % 10) == 6) {
                    top-&gt;clk = 0;
                }
                top-&gt;eval();            // Evaluate model
                cout &lt;&lt; top-&gt;out &lt;&lt; endl;       // Read a output
                main_time++;            // Time passes...
            }

            top-&gt;final();               // Done simulating
            //    // (Though this example doesn&#39;t get here)
            delete top;
        }</code></pre>

<p>Note signals are read and written as member variables of the lower module. You call the eval() method to evaluate the model. When the simulation is complete call the final() method to wrap up any SystemVerilog final blocks, and complete any assertions.</p>

<h1 id="CONNECTING-TO-SYSTEMC">CONNECTING TO SYSTEMC</h1>

<p>Verilator will convert the top level module to a SC_MODULE. This module will plug directly into a SystemC netlist.</p>

<p>The SC_MODULE gets the same pinout as the Verilog module, with the following type conversions: Pins of a single bit become bool. Pins 2-32 bits wide become uint32_t&#39;s. Pins 33-64 bits wide become sc_bv&#39;s or vluint64_t&#39;s depending on the --no-pins64 switch. Wider pins become sc_bv&#39;s. (Uints simulate the fastest so are used where possible.)</p>

<p>Lower modules are not pure SystemC code. This is a feature, as using the SystemC pin interconnect scheme everywhere would reduce performance by an order of magnitude.</p>

<h1 id="DIRECT-PROGRAMMING-INTERFACE-DPI">DIRECT PROGRAMMING INTERFACE (DPI)</h1>

<p>Verilator supports SystemVerilog Direct Programming Interface import and export statements. Only the SystemVerilog form (&quot;DPI-C&quot;) is supported, not the original Synopsys-only DPI.</p>

<h2 id="DPI-Example">DPI Example</h2>

<p>In the SYSTEMC example above, if you wanted to import C++ functions into Verilog, put in our.v:</p>

<pre><code>   import &quot;DPI-C&quot; function integer add (input integer a, input integer b);

   initial begin
      $display(&quot;%x + %x = %x&quot;, 1, 2, add(1,2));
   endtask</code></pre>

<p>Then after Verilating, Verilator will create a file Vour__Dpi.h with the prototype to call this function:</p>

<pre><code>    extern int add (int a, int b);</code></pre>

<p>From the sc_main.cpp file (or another .cpp file passed to the Verilator command line, or the link), you&#39;d then:</p>

<pre><code>    #include &quot;svdpi.h&quot;
    #include &quot;Vour__Dpi.h&quot;
    int add(int a, int b) { return a+b; }</code></pre>

<h2 id="DPI-System-Task-Functions">DPI System Task/Functions</h2>

<p>Verilator extends the DPI format to allow using the same scheme to efficiently add system functions. Simply use a dollar-sign prefixed system function name for the import, but note it must be escaped.</p>

<pre><code>   export &quot;DPI-C&quot; function integer \$myRand;

   initial $display(&quot;myRand=%d&quot;, $myRand());</code></pre>

<p>Going the other direction, you can export Verilog tasks so they can be called from C++:</p>

<pre><code>   export &quot;DPI-C&quot; task publicSetBool;

   task publicSetBool;
      input bit in_bool;
      var_bool = in_bool;
   endtask</code></pre>

<p>Then after Verilating, Verilator will create a file Vour__Dpi.h with the prototype to call this function:</p>

<pre><code>    extern bool publicSetBool(bool in_bool);</code></pre>

<p>From the sc_main.cpp file, you&#39;d then:</p>

<pre><code>    #include &quot;Vour__Dpi.h&quot;
    publicSetBool(value);</code></pre>

<p>Or, alternatively, call the function under the design class. This isn&#39;t DPI compatible but is easier to read and better supports multiple designs.</p>

<pre><code>    #include &quot;Vour__Dpi.h&quot;
    Vour::publicSetBool(value);
    // or top-&gt;publicSetBool(value);</code></pre>

<p>Note that if the DPI task or function accesses any register or net within the RTL, it will require a scope to be set. This can be done using the standard functions within svdpi.h, after the module is instantiated, but before the task(s) and/or function(s) are called.</p>

<p>For example, if the top level module is instantiated with the name &quot;dut&quot; and the name references within tasks are all hierarchical (dotted) names with respect to that top level module, then the scope could be set with</p>

<pre><code>    #include &quot;svdpi.h&quot;
    ...
    svSetScope(svGetScopeFromName(&quot;dut&quot;));</code></pre>

<p>(Remember that Verilator adds a &quot;V&quot; to the top of the module hierarchy.)</p>

<p>Scope can also be set from within a DPI imported C function that has been called from Verilog by querying the scope of that function. See the sections on DPI Context Functions and DPI Header Isolation below and the comments within the svdpi.h header for more information.</p>

<h2 id="DPI-Display-Functions">DPI Display Functions</h2>

<p>Verilator allows writing $display like functions using this syntax:</p>

<pre><code>   import &quot;DPI-C&quot; function void
         \$my_display(input string formatted /*verilator sformat*/ );</code></pre>

<p>The /*verilator sformat*/ indicates that this function accepts a $display like format specifier followed by any number of arguments to satisfy the format.</p>

<h2 id="DPI-Context-Functions">DPI Context Functions</h2>

<p>Verilator supports IEEE DPI Context Functions. Context imports pass the simulator context, including calling scope name, and filename and line number to the C code. For example, in Verilog:</p>

<pre><code>   import &quot;DPI-C&quot; context function int dpic_line();
   initial $display(&quot;This is line %d, again, line %d\n&quot;, `line, dpic_line());</code></pre>

<p>This will call C++ code which may then use the svGet* functions to read information, in this case the line number of the Verilog statement that invoked the dpic_line function:</p>

<pre><code>   int dpic_line() {
       // Get a scope:  svScope scope = svGetScope();

       const char* scopenamep = svGetNameFromScope(scope);
       assert(scopenamep);

       const char* filenamep = &quot;&quot;;
       int lineno = 0;
       if (svGetCallerInfo(&amp;filenamep, &amp;lineno)) {
           printf(&quot;dpic_line called from scope %s on line %d\n&quot;,
              scopenamep, lineno);
           return lineno;
       } else {
           return 0;
       }
   }</code></pre>

<p>See the IEEE Standard for more information.</p>

<h2 id="DPI-Header-Isolation">DPI Header Isolation</h2>

<p>Verilator places the IEEE standard header files such as svdpi.h into a separate include directory, vltstd (VeriLaTor STandarD). When compiling most applications $VERILATOR_ROOT/include/vltstd would be in the include path along with the normal $VERILATOR_ROOT/include. However, when compiling Verilated models into other simulators which have their own svdpi.h and similar standard files with different contents, the vltstd directory should not be included to prevent picking up incompatible definitions.</p>

<h2 id="Public-Functions">Public Functions</h2>

<p>Instead of DPI exporting, there&#39;s also Verilator public functions, which are slightly faster, but less compatible.</p>

<h1 id="VERIFICATION-PROCEDURAL-INTERFACE-VPI">VERIFICATION PROCEDURAL INTERFACE (VPI)</h1>

<p>Verilator supports a very limited subset of the VPI. This subset allows inspection, examination, value change callbacks, and depositing of values to public signals only.</p>

<p>VPI is enabled with the verilator --vpi switch.</p>

<p>To access signals via the VPI, Verilator must be told exactly which signals are to be accessed. This is done using the Verilator public pragmas documented below.</p>

<p>Verilator has an important difference from an event based simulator; signal values that are changed by the VPI will not immediately propagate their values, instead the top level header file&#39;s eval() method must be called. Normally this would be part of the normal evaluation (i.e. the next clock edge), not as part of the value change. This makes the performance of VPI routines extremely fast compared to event based simulators, but can confuse some test-benches that expect immediate propagation.</p>

<p>Note the VPI by its specified implementation will always be much slower than accessing the Verilator values by direct reference (structure-&gt;module-&gt;signame), as the VPI accessors perform lookup in functions at runtime requiring at best hundreds of instructions, while the direct references are evaluated by the compiler and result in only a couple of instructions.</p>

<p>For signal callbacks to work the main loop of the program must call VerilatedVpi::callValueCbs().</p>

<h2 id="VPI-Example">VPI Example</h2>

<p>In the below example, we have readme marked read-only, and writeme which if written from outside the model will have the same semantics as if it changed on the specified clock edge.</p>

<pre><code>    cat &lt;&lt;EOF &gt;our.v
      module our (input clk);
         reg readme   /*verilator public_flat_rd*/;
         reg writeme  /*verilator public_flat_rw @(posedge clk) */;
         initial $finish;
      endmodule
    EOF</code></pre>

<p>There are many online tutorials and books on the VPI, but an example that accesses the above signal &quot;readme&quot; would be:</p>

<pre><code>    cat &lt;&lt;EOF &gt;sim_main.cpp
      #include &quot;Vour.h&quot;
      #include &quot;verilated.h&quot;
      #include &quot;verilated_vpi.h&quot;  // Required to get definitions

      vluint64_t main_time = 0;   // See comments in first example
      double sc_time_stamp() { return main_time; }

      void read_and_check() {
          vpiHandle vh1 = vpi_handle_by_name((PLI_BYTE8*)&quot;TOP.our.readme&quot;, NULL);
          if (!vh1) { vl_fatal(__FILE__, __LINE__, &quot;sim_main&quot;, &quot;No handle found&quot;); }
          const char* name = vpi_get_str(vpiName, vh1);
          printf(&quot;Module name: %s\n&quot;, name);  // Prints &quot;readme&quot;

          s_vpi_value v;
          v.format = vpiIntVal;
          vpi_get_value(vh1, &amp;v);
          printf(&quot;Value of v: %d\n&quot;, v.value.integer);  // Prints &quot;readme&quot;
      }

      int main(int argc, char** argv, char** env) {
          Verilated::commandArgs(argc, argv);
          Vour* top = new Vour;
          Verilated::internalsDump();  // See scopes to help debug
          while (!Verilated::gotFinish()) {
              top-&gt;eval();
              VerilatedVpi::callValueCbs();  // For signal callbacks
              read_and_check();
          }
          delete top;
          exit(0);
      }
    EOF</code></pre>

<h1 id="CROSS-COMPILATION">CROSS COMPILATION</h1>

<p>Verilator supports cross-compiling Verilated code. This is generally used to run Verilator on a Linux system and produce C++ code that is then compiled on Windows.</p>

<p>Cross compilation involves up to three different OSes. The build system is where you configured and compiled Verilator, the host system where you run Verilator, and the target system where you compile the Verilated code and run the simulation.</p>

<p>Currently, Verilator requires the build and host system type to be the same, though the target system type may be different. To support this, ./configure and make Verilator on the build system. Then, run Verilator on the host system. Finally, the output of Verilator may be compiled on the different target system.</p>

<p>To support this, none of the files that Verilator produces will reference any configure generated build-system specific files, such as config.h (which is renamed in Verilator to config_build.h to reduce confusion.) The disadvantage of this approach is that include/verilatedos.h must self-detect the requirements of the target system, rather than using configure.</p>

<p>The target system may also require edits to the Makefiles, the simple Makefiles produced by Verilator presume the target system is the same type as the build system.</p>

<h2 id="Cadence-NC-SystemC-Models">Cadence NC-SystemC Models</h2>

<p>Similar to compiling Verilated designs with gcc, Verilated designs may be compiled inside other simulators that support C++ or SystemC models. One such simulator is Cadence&#39;s NC-SystemC, part of their Incisive Verification Suite. (Highly recommended.)</p>

<p>Using the example files above, the following command will build the model underneath NC:</p>

<pre><code>   cd obj_dir
   ncsc_run \
        sc_main.cpp \
        Vour__ALLcls.cpp \
        Vour__ALLsup.cpp \
        verilated.cpp</code></pre>

<p>For larger designs you&#39;ll want to automate this using makefiles, which pull the names of the .cpp files to compile in from the make variables generated in obj_dir/Vour_classes.mk.</p>

<h1 id="MULTITHREADING">MULTITHREADING</h1>

<p>Verilator experimentally supports multithreading.</p>

<p>With --no-threads, the default, the model is not thread safe, and any use of more than one thread calling into one or even different Verilated models may result in unpredictable behavior. This gives the highest single thread performance.</p>

<p>With --threads 1, the generated model is single threaded, however the support libraries are multithread safe. This allows different instantiations of model(s) to potentially each be run under a different thread. All threading is the responsibility of the user&#39;s C++ testbench.</p>

<p>With --threads N, where N is at least 2, the generated model will be designed to run in parallel on N threads. The thread calling eval() provides one of those threads, and the generated model will create and manage the other N-1 threads. It&#39;s the client&#39;s responsibility not to oversubscribe the available CPU cores. Under CPU oversubscription, the Verilated model should not livelock nor deadlock, however, you can expect performance to be far worse than it would be with proper stoichiometry of threads and CPU cores.</p>

<p>With --trace-fst-thread, tracing occurs in a separate thread from the main simulation thread(s). This option is orthogonal to --threads.</p>

<p>The remainder of this section describe behavior with --threads 1 or --threads N (not --no-threads).</p>

<p>VL_THREADED is defined when compiling a threaded Verilated module, causing the Verilated support classes become threadsafe.</p>

<p>The thread used for constructing a model must the the same thread that calls eval() into the model, this is called the &quot;eval thread&quot;. The thread used to perform certain global operations such as saving and tracing must be done by a &quot;main thread&quot;. In most cases the eval thread and main thread are the same thread (i.e. the user&#39;s top C++ testbench runs on a single thread), but this is not required.</p>

<p>When running a multithreaded model, the default Linux task scheduler often works against the model, by assuming threads are short lived, and thus often schedules threads using multiple hyperthreads within the same physical core. For best performance use the <code>numactl</code> program to (when the threading count fits) select unique physical cores on the same socket. For example, if a model was Verilated with &quot;--threads 4&quot;, we consult</p>

<pre><code>   egrep &#39;processor|physical id|core id&#39; /proc/cpuinfo</code></pre>

<p>To select cores 0, 1, 2, and 3 that are all located on the same socket (0) but different physical cores. (Also useful is &quot;numactl --hardware&quot;, or <code>lscpu</code> but those doesn&#39;t show Hyperthreading cores.) Then we execute</p>

<pre><code>   numactl -m 0 -C 0,1,2,3 -- verilated_executable_name</code></pre>

<p>This will limit memory to socket 0, and threads to cores 0, 1, 2, 3, (presumably on socket 0) optimizing performance. Of course this must be adjusted if you want another simulator using e.g. socket 1, or if you Verilated with a different number of threads. To see what CPUs are actually used, use --prof-threads.</p>

<h2 id="Multithreaded-Verilog-and-Library-Support">Multithreaded Verilog and Library Support</h2>

<p>$display/$stop/$finish are delayed until the end of an eval() call in order to maintain ordering between threads. This may result in additional tasks completing after the $stop or $finish.</p>

<ul>

<p>If using --coverage, the coverage routines are fully thread safe.</p>

<p>If using --dpi, Verilator assumes pure DPI imports are thread safe, balancing performance versus saftey. See --threads-dpi.</p>

<p>If using --savable, the save/restore classes are not multithreaded and are must be called only by the eval thread.</p>

<p>If using --sc, the SystemC kernel is not thread safe, therefore the eval thread and main thread must be the same.</p>

<p>If using --trace, the tracing classes must be constructed and called from the main thread.</p>

<p>If using --vpi, since SystemVerilog VPI was not architected by IEEE to be multithreaded, Verilator requires all VPI calls are only made from the main thread.</p>

</ul>

<h1 id="CONFIGURATION-FILES">CONFIGURATION FILES</h1>

<p>In addition to the command line, warnings and other features may be controlled by configuration files, typically named with the .vlt extension. An example:</p>

<pre><code>  `verilator_config
  lint_off -msg WIDTH
  lint_off -msg CASEX  -file &quot;silly_vendor_code.v&quot;</code></pre>

<p>This disables WIDTH warnings globally, and CASEX for a specific file.</p>

<p>Configuration files are parsed after the normal Verilog preprocessing, so `ifdefs, `defines, and comments may be used as if it were normal Verilog code.</p>

<p>The grammar of configuration commands is as follows:</p>

<dl>

<dt id="verilator_config">`verilator_config</dt>
<dd>

<p>Take remaining text up the the next `verilog mode switch and treat it as Verilator configuration commands.</p>

</dd>
<dt id="coverage_on--file-filename--lines-line---line">coverage_on [-file &quot;&lt;filename&gt;&quot; [-lines &lt;line&gt; [ - &lt;line&gt; ]]]</dt>
<dd>

</dd>
<dt id="coverage_off--file-filename--lines-line---line">coverage_off [-file &quot;&lt;filename&gt;&quot; [-lines &lt;line&gt; [ - &lt;line&gt; ]]]</dt>
<dd>

<p>Enable/disable coverage for the specified filename (or wildcard with &#39;*&#39; or &#39;?&#39;, or all files if omitted) and range of line numbers (or all lines if omitted). Often used to ignore an entire module for coverage analysis purposes.</p>

</dd>
<dt id="lint_on--msg-message--file-filename--lines-line---line">lint_on [-msg &lt;message&gt;] [-file &quot;&lt;filename&gt;&quot; [-lines &lt;line&gt; [ - &lt;line&gt;]]]</dt>
<dd>

</dd>
<dt id="lint_off--msg-message--file-filename--lines-line---line">lint_off [-msg &lt;message&gt;] [-file &quot;&lt;filename&gt;&quot; [-lines &lt;line&gt; [ - &lt;line&gt;]]]</dt>
<dd>

<p>Enable/disables the specified lint warning, in the specified filename (or wildcard with &#39;*&#39; or &#39;?&#39;, or all files if omitted) and range of line numbers (or all lines if omitted).</p>

<p>With lint_off using &#39;*&#39; will override any lint_on directives in the source, i.e. the warning will still not be printed.</p>

<p>If the -msg is omitted, all lint warnings (see list in -Wno-lint) are enabled/disabled. This will override all later lint warning enables for the specified region.</p>

</dd>
<dt id="tracing_on--file-filename--lines-line---line">tracing_on [-file &quot;&lt;filename&gt;&quot; [-lines &lt;line&gt; [ - &lt;line&gt; ]]]</dt>
<dd>

</dd>
<dt id="tracing_off--file-filename--lines-line---line">tracing_off [-file &quot;&lt;filename&gt;&quot; [-lines &lt;line&gt; [ - &lt;line&gt; ]]]</dt>
<dd>

<p>Enable/disable waveform tracing for all future signals declared in the specified filename (or wildcard with &#39;*&#39; or &#39;?&#39;, or all files if omitted) and range of line numbers (or all lines if omitted).</p>

<p>For tracing_off, cells below any module in the files/ranges specified will also not be traced.</p>

</dd>
</dl>

<h1 id="LANGUAGE-STANDARD-SUPPORT">LANGUAGE STANDARD SUPPORT</h1>

<h2 id="Verilog-2001-IEEE-1364-2001-Support">Verilog 2001 (IEEE 1364-2001) Support</h2>

<p>Verilator supports most Verilog 2001 language features. This includes signed numbers, &quot;always @*&quot;, generate statements, multidimensional arrays, localparam, and C-style declarations inside port lists.</p>

<h2 id="Verilog-2005-IEEE-1364-2005-Support">Verilog 2005 (IEEE 1364-2005) Support</h2>

<p>Verilator supports most Verilog 2005 language features. This includes the `begin_keywords and `end_keywords compiler directives, $clog2, and the uwire keyword.</p>

<h2 id="SystemVerilog-2005-IEEE-1800-2005-Support">SystemVerilog 2005 (IEEE 1800-2005) Support</h2>

<p>Verilator supports ==? and !=? operators, ++ and -- in some contexts, $bits, $countones, $error, $fatal, $info, $isunknown, $onehot, $onehot0, $unit, $warning, always_comb, always_ff, always_latch, bit, byte, chandle, const, do-while, enum, export, final, import, int, interface, logic, longint, modport, package, program, shortint, struct, time, typedef, union, var, void, priority case/if, and unique case/if.</p>

<p>It also supports .name and .* interconnection.</p>

<p>Verilator partially supports concurrent assert and cover statements; see the enclosed coverage tests for the syntax which is allowed.</p>

<h2 id="SystemVerilog-2012-IEEE-1800-2012-Support">SystemVerilog 2012 (IEEE 1800-2012) Support</h2>

<p>Verilator implements a full SystemVerilog 2012 preprocessor, including function call-like preprocessor defines, default define arguments, `__FILE__, `__LINE__ and `undefineall.</p>

<p>Verilator currently has some support for SystemVerilog synthesis constructs. As SystemVerilog features enter common usage they are added; please file a bug if a feature you need is missing.</p>

<h2 id="SystemVerilog-2017-IEEE-1800-2017-Support">SystemVerilog 2017 (IEEE 1800-2017) Support</h2>

<p>Verilator supports the 2017 &quot;for&quot; loop constructs, and several minor cleanups made in 1800-2017.</p>

<h2 id="Verilog-AMS-Support">Verilog AMS Support</h2>

<p>Verilator implements a very small subset of Verilog AMS (Verilog Analog and Mixed-Signal Extensions) with the subset corresponding to those VMS keywords with near equivalents in the Verilog 2005 or SystemVerilog 2009 languages.</p>

<p>AMS parsing is enabled with &quot;--language VAMS&quot; or &quot;--language 1800+VAMS&quot;.</p>

<p>At present Verilator implements ceil, exp, floor, ln, log, pow, sqrt, string, and wreal.</p>

<h2 id="Synthesis-Directive-Assertion-Support">Synthesis Directive Assertion Support</h2>

<p>With the --assert switch, Verilator reads any &quot;//synopsys full_case&quot; or &quot;//synopsys parallel_case&quot; directives. The same applies to any &quot;//ambit synthesis&quot;, &quot;//cadence&quot; or &quot;//pragma&quot; directives of the same form.</p>

<p>When these synthesis directives are discovered, Verilator will either formally prove the directive to be true, or failing that, will insert the appropriate code to detect failing cases at runtime and print an &quot;Assertion failed&quot; error message.</p>

<p>Verilator likewise also asserts any &quot;unique&quot; or &quot;priority&quot; SystemVerilog keywords on case statement, as well as &quot;unique&quot; on if statements. However, &quot;priority if&quot; is currently simply ignored.</p>

<h1 id="LANGUAGE-EXTENSIONS">LANGUAGE EXTENSIONS</h1>

<p>The following additional constructs are the extensions Verilator supports on top of standard Verilog code. Using these features outside of comments or `ifdef&#39;s may break other tools.</p>

<dl>

<dt id="FILE__">`__FILE__</dt>
<dd>

<p>The __FILE__ define expands to the current filename as a string, like C++&#39;s __FILE__. This was incorporated into to the 1800-2009 standard (but supported by Verilator since 2006!)</p>

</dd>
<dt id="LINE__">`__LINE__</dt>
<dd>

<p>The __LINE__ define expands to the current filename as a string, like C++&#39;s __LINE__. This was incorporated into to the 1800-2009 standard (but supported by Verilator since 2006!)</p>

</dd>
<dt id="error-string">`error <i>string</i></dt>
<dd>

<p>This will report an error when encountered, like C++&#39;s #error.</p>

</dd>
<dt id="c-string">$c(<i>string</i>, ...);</dt>
<dd>

<p>The string will be embedded directly in the output C++ code at the point where the surrounding Verilog code is compiled. It may either be a standalone statement (with a trailing ; in the string), or a function that returns up to a 32-bit number (without a trailing ;). This can be used to call C++ functions from your Verilog code.</p>

<p>String arguments will be put directly into the output C++ code. Expression arguments will have the code to evaluate the expression inserted. Thus to call a C++ function, $c(&quot;func(&quot;,a,&quot;)&quot;) will result in &#39;func(a)&#39; in the output C++ code. For input arguments, rather than hard-coding variable names in the string $c(&quot;func(a)&quot;), instead pass the variable as an expression $c(&quot;func(&quot;,a,&quot;)&quot;). This will allow the call to work inside Verilog functions where the variable is flattened out, and also enable other optimizations.</p>

<p>If you will be reading or writing any Verilog variables inside the C++ functions, the Verilog signals must be declared with /*verilator public*/.</p>

<p>You may also append an arbitrary number to $c, generally the width of the output. [signal_32_bits = $c32(&quot;...&quot;);] This allows for compatibility with other simulators which require a differently named PLI function name for each different output width.</p>

</dd>
<dt id="display-write-fdisplay-fwrite-sformat-swrite">$display, $write, $fdisplay, $fwrite, $sformat, $swrite</dt>
<dd>

<p>Format arguments may use C fprintf sizes after the % escape. Per the Verilog standard, %x prints a number with the natural width, and %0x prints a number with minimum width. Verilator extends this so %5x prints 5 digits per the C standard (it&#39;s unspecified in Verilog).</p>

</dd>
<dt id="coverage_block_off">`coverage_block_off</dt>
<dd>

<p>Specifies the entire begin/end block should be ignored for coverage analysis. Must be inside a basic block, e.g. within a begin/end pair. Same as /* verilator coverage_block_off */.</p>

</dd>
<dt id="systemc_header">`systemc_header</dt>
<dd>

<p>Take remaining text up to the next `verilog or `systemc_... mode switch and place it verbatim into the output .h file&#39;s header. Must be placed as a module item, e.g. directly inside a module/endmodule pair. Despite the name of this macro, this also works in pure C++ code.</p>

</dd>
<dt id="systemc_ctor">`systemc_ctor</dt>
<dd>

<p>Take remaining text up to the next `verilog or `systemc_... mode switch and place it verbatim into the C++ class constructor. Must be placed as a module item, e.g. directly inside a module/endmodule pair. Despite the name of this macro, this also works in pure C++ code.</p>

</dd>
<dt id="systemc_dtor">`systemc_dtor</dt>
<dd>

<p>Take remaining text up to the next `verilog or `systemc_... mode switch and place it verbatim into the C++ class destructor. Must be placed as a module item, e.g. directly inside a module/endmodule pair. Despite the name of this macro, this also works in pure C++ code.</p>

</dd>
<dt id="systemc_interface">`systemc_interface</dt>
<dd>

<p>Take remaining text up to the next `verilog or `systemc_... mode switch and place it verbatim into the C++ class interface. Must be placed as a module item, e.g. directly inside a module/endmodule pair. Despite the name of this macro, this also works in pure C++ code.</p>

</dd>
<dt id="systemc_imp_header">`systemc_imp_header</dt>
<dd>

<p>Take remaining text up to the next `verilog or `systemc_... mode switch and place it verbatim into the header of all files for this C++ class implementation. Must be placed as a module item, e.g. directly inside a module/endmodule pair. Despite the name of this macro, this also works in pure C++ code.</p>

</dd>
<dt id="systemc_implementation">`systemc_implementation</dt>
<dd>

<p>Take remaining text up to the next `verilog or `systemc_... mode switch and place it verbatim into a single file of the C++ class implementation. Must be placed as a module item, e.g. directly inside a module/endmodule pair. Despite the name of this macro, this also works in pure C++ code.</p>

<p>If you will be reading or writing any Verilog variables in the C++ functions, the Verilog signals must be declared with /*verilator public*/. See also the public task feature; writing an accessor may result in cleaner code.</p>

</dd>
<dt id="SYSTEMVERILOG">`SYSTEMVERILOG</dt>
<dd>

<p>The SYSTEMVERILOG, SV_COV_START and related standard defines are set by default when --language is 1800-*.</p>

</dd>
<dt id="VERILATOR">`VERILATOR</dt>
<dd>

</dd>
<dt id="verilator">`verilator</dt>
<dd>

</dd>
<dt id="verilator3">`verilator3</dt>
<dd>

<p>The VERILATOR, verilator and verilator3 defines are set by default so you may `ifdef around compiler specific constructs.</p>

</dd>
<dt id="verilator_config1">`verilator_config</dt>
<dd>

<p>Take remaining text up the the next `verilog mode switch and treat it as Verilator configuration commands.</p>

</dd>
<dt id="verilog">`verilog</dt>
<dd>

<p>Switch back to processing Verilog code after a `systemc_... mode switch. The Verilog code returns to the last language mode specified with `begin_keywords, or SystemVerilog if none was specified.</p>

</dd>
<dt id="verilator-clock_enable">/*verilator clock_enable*/</dt>
<dd>

<p>Used after a signal declaration to indicate the signal is used to gate a clock, and the user takes responsibility for insuring there are no races related to it. (Typically by adding a latch, and running static timing analysis.) For example:</p>

<pre><code>   reg enable_r /*verilator clock_enable*/;
   wire gated_clk = clk &amp; enable_r;
   always_ff @ (posedge clk)
      enable_r &lt;= enable_early;</code></pre>

<p>The clock_enable attribute will cause the clock gate to be ignored in the scheduling algorithm, sometimes required for correct clock behavior, and always improving performance. It&#39;s also a good idea to enable the IMPERFECTSCH warning, to insure all clock enables are properly recognized.</p>

</dd>
<dt id="verilator-clocker">/*verilator clocker*/</dt>
<dd>

</dd>
<dt id="verilator-no_clocker">/*verilator no_clocker*/</dt>
<dd>

<p>Used after a signal declaration to indicate the signal is used as clock or not. This information is used by Verilator to mark the signal as clocker and propagate the clocker attribute automatically to derived signals. See <code>--clk</code> for more information.</p>

</dd>
<dt id="verilator-coverage_block_off">/*verilator coverage_block_off*/</dt>
<dd>

<p>Specifies the entire begin/end block should be ignored for coverage analysis purposes.</p>

</dd>
<dt id="verilator-coverage_off">/*verilator coverage_off*/</dt>
<dd>

<p>Specifies that following lines of code should have coverage disabled. Often used to ignore an entire module for coverage analysis purposes.</p>

</dd>
<dt id="verilator-coverage_on">/*verilator coverage_on*/</dt>
<dd>

<p>Specifies that following lines of code should have coverage re-enabled (if appropriate --coverage flags are passed) after being disabled earlier with /*verilator coverage_off*/.</p>

</dd>
<dt id="verilator-inline_module">/*verilator inline_module*/</dt>
<dd>

<p>Specifies the module the comment appears in may be inlined into any modules that use this module. This is useful to speed up simulation time with some small loss of trace visibility and modularity. Note signals under inlined submodules will be named <i>submodule</i>__DOT__<i>subsignal</i> as C++ does not allow &quot;.&quot; in signal names. When tracing such signals the tracing routines will replace the __DOT__ with the period.</p>

</dd>
<dt id="verilator-isolate_assignments">/*verilator isolate_assignments*/</dt>
<dd>

<p>Used after a signal declaration to indicate the assignments to this signal in any blocks should be isolated into new blocks. When there is a large combinatorial block that is resulting in a UNOPTFLAT warning, attaching this to the signal causing a false loop may clear up the problem.</p>

<p>IE, with the following</p>

<pre><code>    reg splitme /* verilator isolate_assignments*/;
    // Note the placement of the semicolon above
    always @* begin
      if (....) begin
         splitme = ....;
         other assignments
      end
    end</code></pre>

<p>Verilator will internally split the block that assigns to &quot;splitme&quot; into two blocks:</p>

<p>It would then internally break it into (sort of):</p>

<pre><code>    // All assignments excluding those to splitme
    always @* begin
      if (....) begin
         other assignments
      end
    end
    // All assignments to splitme
    always @* begin
      if (....) begin
         splitme = ....;
      end
    end</code></pre>

</dd>
<dt id="verilator-lint_off-msg">/*verilator lint_off <i>msg</i>*/</dt>
<dd>

<p>Disable the specified warning message for any warnings following the comment.</p>

</dd>
<dt id="verilator-lint_on-msg">/*verilator lint_on <i>msg</i>*/</dt>
<dd>

<p>Re-enable the specified warning message for any warnings following the comment.</p>

</dd>
<dt id="verilator-lint_restore">/*verilator lint_restore*/</dt>
<dd>

<p>After a /*verilator lint_save*/, pop the stack containing lint message state. Often this is useful at the bottom of include files.</p>

</dd>
<dt id="verilator-lint_save">/*verilator lint_save*/</dt>
<dd>

<p>Push the current state of what lint messages are turned on or turned off to a stack. Later meta-comments may then lint_on or lint_off specific messages, then return to the earlier message state by using /*verilator lint_restore*/. For example:</p>

<pre><code>    // verilator lint_save
    // verilator lint_off SOME_WARNING
    ...  // code needing SOME_WARNING turned off
    // verilator lint_restore</code></pre>

<p>If SOME_WARNING was on before the lint_off, it will now be restored to on, and if it was off before the lint_off it will remain off.</p>

</dd>
<dt id="verilator-no_inline_module">/*verilator no_inline_module*/</dt>
<dd>

<p>Specifies the module the comment appears in should not be inlined into any modules that use this module. This is useful especially at the top level module to reduce the size of the interface class, to aid compile time at a small performance loss.</p>

</dd>
<dt id="verilator-no_inline_task">/*verilator no_inline_task*/</dt>
<dd>

<p>Used in a function or task variable definition section to specify the function or task should not be inlined into where it is used. This may reduce the size of the final executable when a task is used a very large number of times. For this flag to work, the task and tasks below it must be pure; they cannot reference any variables outside the task itself.</p>

</dd>
<dt id="verilator-public-parameter">/*verilator public*/ (parameter)</dt>
<dd>

<p>Used after a parameter declaration to indicate the emitted C code should have the parameter values visible. Due to C++ language restrictions, this may only be used on 64-bit or narrower integral enumerations.</p>

<pre><code>    parameter [2:0] PARAM /*verilator public*/ = 2&#39;b0;</code></pre>

</dd>
<dt id="verilator-public-typedef-enum">/*verilator public*/ (typedef enum)</dt>
<dd>

<p>Used after an enum typedef declaration to indicate the emitted C code should have the enum values visible. Due to C++ language restrictions, this may only be used on 64-bit or narrower integral enumerations.</p>

<pre><code>    typedef enum logic [2:0] { ZERO = 3&#39;b0 } pub_t /*verilator public*/;</code></pre>

</dd>
<dt id="verilator-public-variable">/*verilator public*/ (variable)</dt>
<dd>

<p>Used after an input, output, register, or wire declaration to indicate the signal should be declared so that C code may read or write the value of the signal. This will also declare this module public, otherwise use /*verilator public_flat*/.</p>

<p>Instead of using public variables, consider instead making a DPI or public function that accesses the variable. This is nicer as it provides an obvious entry point that is also compatible across simulators.</p>

</dd>
<dt id="verilator-public-task-function">/*verilator public*/ (task/function)</dt>
<dd>

<p>Used inside the declaration section of a function or task declaration to indicate the function or task should be made into a C++ function, public to outside callers. Public tasks will be declared as a void C++ function, public functions will get the appropriate non-void (bool, uint32_t, etc) return type. Any input arguments will become C++ arguments to the function. Any output arguments will become C++ reference arguments. Any local registers/integers will become function automatic variables on the stack.</p>

<p>Wide variables over 64 bits cannot be function returns, to avoid exposing complexities. However, wide variables can be input/outputs; they will be passed as references to an array of 32-bit numbers.</p>

<p>Generally, only the values of stored state (flops) should be written, as the model will NOT notice changes made to variables in these functions. (Same as when a signal is declared public.)</p>

<p>You may want to use DPI exports instead, as it&#39;s compatible with other simulators.</p>

</dd>
<dt id="verilator-public_flat-variable">/*verilator public_flat*/ (variable)</dt>
<dd>

<p>Used after an input, output, register, or wire declaration to indicate the signal should be declared so that C code may read or write the value of the signal. This will not declare this module public, which means the name of the signal or path to it may change based upon the module inlining which takes place.</p>

</dd>
<dt id="verilator-public_flat_rd-variable">/*verilator public_flat_rd*/ (variable)</dt>
<dd>

<p>Used after an input, output, register, or wire declaration to indicate the signal should be declared public_flat (see above), but read-only.</p>

</dd>
<dt id="verilator-public_flat_rw-edge_list-variable">/*verilator public_flat_rw @(&lt;edge_list&gt;) */ (variable)</dt>
<dd>

<p>Used after an input, output, register, or wire declaration to indicate the signal should be declared public_flat_rd (see above), and also writable, where writes should be considered to have the timing specified by the given sensitivity edge list.</p>

</dd>
<dt id="verilator-public_module">/*verilator public_module*/</dt>
<dd>

<p>Used after a module statement to indicate the module should not be inlined (unless specifically requested) so that C code may access the module. Verilator automatically sets this attribute when the module contains any public signals or `systemc_ directives. Also set for all modules when using the --public switch.</p>

</dd>
<dt id="verilator-sc_clock">/*verilator sc_clock*/</dt>
<dd>

<p>Rarely needed. Used after an input declaration to indicate the signal should be declared in SystemC as a sc_clock instead of a bool. This was needed in SystemC 1.1 and 1.2 only; versions 2.0 and later do not require clock pins to be sc_clocks and this is no longer needed.</p>

</dd>
<dt id="verilator-sc_bv">/*verilator sc_bv*/</dt>
<dd>

<p>Used after a port declaration. It sets the port to be of sc_bv&lt;<i>width</i>&gt; type, instead of bool, vluint32_t or vluint64_t. This may be useful if the port width is parametrized and different of such modules interface a templated module (such as a transactor) or for other reasons. In general you should avoid using this attribute when not necessary as with increasing usage of sc_bv the performance increases significantly.</p>

</dd>
<dt id="verilator-sformat">/*verilator sformat*/</dt>
<dd>

<p>Attached to the final input of a function or task &quot;input string&quot; to indicate the function or task should pass all remaining arguments through $sformatf. This allows creation of DPI functions with $display like behavior. See the test_regress/t/t_dpi_display.v file for an example.</p>

</dd>
<dt id="verilator-tag-text">/*verilator tag &lt;text...&gt;*/</dt>
<dd>

<p>Attached after a variable or structure member to indicate opaque (to Verilator) text that should be passed through to the XML output as a tag, for use by downstream applications.</p>

</dd>
<dt id="verilator-tracing_off">/*verilator tracing_off*/</dt>
<dd>

<p>Disable waveform tracing for all future signals that are declared in this module, or cells below this module. Often this is placed just after a primitive&#39;s module statement, so that the entire module and cells below it are not traced.</p>

</dd>
<dt id="verilator-tracing_on">/*verilator tracing_on*/</dt>
<dd>

<p>Re-enable waveform tracing for all future signals or cells that are declared.</p>

</dd>
</dl>

<h1 id="LANGUAGE-LIMITATIONS">LANGUAGE LIMITATIONS</h1>

<p>There are some limitations and lack of features relative to a commercial simulator, by intent. User beware.</p>

<p>It is strongly recommended you use a lint tool before running this program. Verilator isn&#39;t designed to easily uncover common mistakes that a lint program will find for you.</p>

<h2 id="Synthesis-Subset">Synthesis Subset</h2>

<p>Verilator supports only the Synthesis subset with a few minor additions such as $stop, $finish and $display. That is, you cannot use hierarchical references, events or similar features of the Verilog language. It also simulates as Synopsys&#39;s Design Compiler would; namely a block of the form:</p>

<pre><code>        always @ (x)   y = x &amp; z;</code></pre>

<p>This will recompute y when there is even a potential for change in x or a change in z, that is when the flops computing x or z evaluate (which is what Design Compiler will synthesize.) A compliant simulator would only calculate y if x changes. Use Verilog-Mode&#39;s /*AS*/ or Verilog 2001&#39;s always @* to reduce missing activity items. Avoid putting $displays in combo blocks, as they may print multiple times when not desired, even on compliant simulators as event ordering is not specified.</p>

<h2 id="Signal-Naming">Signal Naming</h2>

<p>To avoid conflicts with C symbol naming, any character in a signal name that is not alphanumeric nor a single underscore will be replaced by __0hh where hh is the hex code of the character. To avoid conflicts with Verilator&#39;s internal symbols, any double underscore are replaced with ___05F (5F is the hex code of an underscore.)</p>

<h2 id="Bind">Bind</h2>

<p>Verilator only supports &quot;bind&quot; to a target module name, not an instance path.</p>

<h2 id="Dotted-cross-hierarchy-references">Dotted cross-hierarchy references</h2>

<p>Verilator supports dotted references to variables, functions and tasks in different modules. However, references into named blocks and function-local variables are not supported. The portion before the dot must have a constant value; for example a[2].b is acceptable, while a[x].b is not.</p>

<p>References into generated and arrayed instances use the instance names specified in the Verilog standard; arrayed instances are named {cellName}[{instanceNumber}] in Verilog, which becomes {cellname}__BRA__{instanceNumber}__KET__ inside the generated C++ code.</p>

<p>Verilator creates numbered &quot;genblk&quot; when a begin: name is not specified around a block inside a generate statement. These numbers may differ between other simulators, but the Verilog specification does not allow users to use these names, so it should not matter.</p>

<p>If you are having trouble determining where a dotted path goes wrong, note that Verilator will print a list of known scopes to help your debugging.</p>

<h2 id="Floating-Point">Floating Point</h2>

<p>Floating Point (real) numbers are supported.</p>

<h2 id="Latches">Latches</h2>

<p>Verilator is optimized for edge sensitive (flop based) designs. It will attempt to do the correct thing for latches, but most performance optimizations will be disabled around the latch.</p>

<h2 id="Structures-and-Unions">Structures and Unions</h2>

<p>Verilator only presently supports packed structs and packed unions. Rand and randc tags on members are simply ignored. All structures and unions are represented as a single vector, which means that generating one member of a structure from blocking, and another from non-blocking assignments is unsupported.</p>

<h2 id="Time">Time</h2>

<p>All delays (#) are ignored, as they are in synthesis.</p>

<h2 id="Unknown-states">Unknown states</h2>

<p>Verilator is mostly a two state simulator, not a four state simulator. However, it has two features which uncover most initialization bugs (including many that a four state simulator will miss.)</p>

<p>Identity comparisons (=== or !==) are converted to standard ==/!== when neither side is a constant. This may make the expression result differ from a four state simulator. An === comparison to X will always be false, so that Verilog code which checks for uninitialized logic will not fire.</p>

<p>Assigning a variable to a X will actually assign the variable to a random value (see the --x-assign switch and +verilator+rand+reset runtime switch.) Thus if the value is actually used, the random value should cause downstream errors. Integers also randomize, even though the Verilog 2001 specification says they initialize to zero.</p>

<p>All variables, depending on --x-initial setting, are typically randomly initialized using a function. By running several random simulation runs you can determine that reset is working correctly. On the first run, the function initializes variables to zero. On the second, have it initialize variables to one. On the third and following runs have it initialize them randomly. If the results match, reset works. (Note this is what the hardware will really do.) In practice, just setting all variables to one at startup finds most problems (since typically control signals are active-high).</p>

<p>--x-assign applies to variables explicitly initialized or assigned to X. Uninitialized clocks are initialized to zero, while all other state holding variables are initialized to a random value. Event driven simulators will generally trigger an edge on a transition from X to 1 (<code>posedge</code>) or X to 0 (<code>negedge</code>). However, by default, since clocks are initialized to zero, Verilator will not trigger an initial negedge. Some code (particularly for reset) may rely on X-&gt;0 triggering an edge. The --x-initial-edge switch enables this behavior. Comparing runs with and without this switch will find such problems.</p>

<h2 id="Tri-Inout">Tri/Inout</h2>

<p>Verilator converts some simple tristate structures into two state. Pullup, pulldown, bufif0, bufif1, notif0, notif1, pmos, nmos, tri0 and tri1 are also supported. Simple comparisons with === 1&#39;bz are also supported.</p>

<p>An assignment of the form:</p>

<pre><code>    inout driver;
    wire driver = (enable) ? output_value : 1&#39;bz;</code></pre>

<p>Will be converted to</p>

<pre><code>    input driver;       // Value being driven in from &quot;external&quot; drivers
    output driver__en;  // True if driven from this module
    output driver__out; // Value being driven from this module</code></pre>

<p>External logic will be needed to combine these signals with any external drivers.</p>

<p>Tristate drivers are not supported inside functions and tasks; an inout there will be considered a two state variable that is read and written instead of a four state variable.</p>

<h2 id="Functions-Tasks">Functions &amp; Tasks</h2>

<p>All functions and tasks will be inlined (will not become functions in C.) The only support provided is for simple statements in tasks (which may affect global variables).</p>

<p>Recursive functions and tasks are not supported. All inputs and outputs are automatic, as if they had the Verilog 2001 &quot;automatic&quot; keyword prepended. (If you don&#39;t know what this means, Verilator will do what you probably expect -- what C does. The default behavior of Verilog is different.)</p>

<h2 id="Generated-Clocks">Generated Clocks</h2>

<p>Verilator attempts to deal with generated and enabled clocks correctly, however some cases cause problems in the scheduling algorithm which is optimized for performance. The safest option is to have all clocks as primary inputs to the model, or wires directly attached to primary inputs. For proper behavior clock enables may also need the /*verilator clock_enable*/ attribute.</p>

<h2 id="Ranges-must-be-big-bit-endian">Ranges must be big-bit-endian</h2>

<p>Bit ranges must be numbered with the MSB being numbered greater or the same as the LSB. Little-bit-endian buses [0:15] are not supported as they aren&#39;t easily made compatible with C++.</p>

<h2 id="Gate-Primitives">Gate Primitives</h2>

<p>The 2-state gate primitives (and, buf, nand, nor, not, or, xnor, xor) are directly converted to behavioral equivalents. The 3-state and MOS gate primitives are not supported. Tables are not supported.</p>

<h2 id="Specify-blocks">Specify blocks</h2>

<p>All specify blocks and timing checks are ignored.</p>

<h2 id="Array-Initialization">Array Initialization</h2>

<p>When initializing a large array, you need to use non-delayed assignments. Verilator will tell you when this needs to be fixed; see the BLKLOOPINIT error for more information.</p>

<h2 id="Array-Out-of-Bounds">Array Out of Bounds</h2>

<p>Writing a memory element that is outside the bounds specified for the array may cause a different memory element inside the array to be written instead. For power-of-2 sized arrays, Verilator will give a width warning and the address. For non-power-of-2-sizes arrays, index 0 will be written.</p>

<p>Reading a memory element that is outside the bounds specified for the array will give a width warning and wrap around the power-of-2 size. For non-power-of-2 sizes, it will return a unspecified constant of the appropriate width.</p>

<h2 id="Assertions">Assertions</h2>

<p>Verilator is beginning to add support for assertions. Verilator currently only converts assertions to simple &quot;if (...) error&quot; statements, and coverage statements to increment the line counters described in the coverage section.</p>

<p>Verilator does not support SEREs yet. All assertion and coverage statements must be simple expressions that complete in one cycle. (Arguably SEREs are much of the point, but one must start somewhere.)</p>

<h2 id="Language-Keyword-Limitations">Language Keyword Limitations</h2>

<p>This section describes specific limitations for each language keyword.</p>

<dl>

<dt id="FILE__-__LINE__-begin_keywords-begin_keywords-begin_keywords-begin_keywords-begin_keywords-define-else-elsif-end_keywords-endif-error-ifdef-ifndef-include-line-systemc_ctor-systemc_dtor-systemc_header-systemc_imp_header-systemc_implementation-systemc_interface-timescale-undef-verilog">`__FILE__, `__LINE__, `begin_keywords, `begin_keywords, `begin_keywords, `begin_keywords, `begin_keywords, `define, `else, `elsif, `end_keywords, `endif, `error, `ifdef, `ifndef, `include, `line, `systemc_ctor, `systemc_dtor, `systemc_header, `systemc_imp_header, `systemc_implementation, `systemc_interface, `timescale, `undef, `verilog</dt>
<dd>

<p>Fully supported.</p>

</dd>
<dt id="always-always_comb-always_ff-always_latch-and-assign-begin-buf-byte-case-casex-casez-default-defparam-do-while-else-end-endcase-endfunction-endgenerate-endmodule-endspecify-endtask-final-for-function-generate-genvar-if-initial-inout-input-int-integer-localparam-logic-longint-macromodule-module-nand-negedge-nor-not-or-output-parameter-posedge-reg-scalared-shortint-signed-supply0-supply1-task-time-tri-typedef-var-vectored-while-wire-xnor-xor">always, always_comb, always_ff, always_latch, and, assign, begin, buf, byte, case, casex, casez, default, defparam, do-while, else, end, endcase, endfunction, endgenerate, endmodule, endspecify, endtask, final, for, function, generate, genvar, if, initial, inout, input, int, integer, localparam, logic, longint, macromodule, module, nand, negedge, nor, not, or, output, parameter, posedge, reg, scalared, shortint, signed, supply0, supply1, task, time, tri, typedef, var, vectored, while, wire, xnor, xor</dt>
<dd>

<p>Generally supported.</p>

</dd>
<dt id="operators">++, -- operators</dt>
<dd>

<p>Increment/decrement can only be used as standalone statements or in for loops. They cannot be used as side effect operators inside more complicate expressions (&quot;a = b++;&quot;).</p>

</dd>
<dt id="operator">&#39;{} operator</dt>
<dd>

<p>Assignment patterns with order based, default, constant integer (array) or member identifier (struct/union) keys are supported. Data type keys and keys which are computed from a constant expression are not supported.</p>

</dd>
<dt id="cast-operator">cast operator</dt>
<dd>

<p>Casting is supported only between simple scalar types, signed and unsigned, not arrays nor structs.</p>

</dd>
<dt id="chandle">chandle</dt>
<dd>

<p>Treated as a &quot;longint&quot;; does not yet warn about operations that are specified as illegal on chandles.</p>

</dd>
<dt id="disable">disable</dt>
<dd>

<p>Disable statements may be used only if the block being disabled is a block the disable statement itself is inside. This was commonly used to provide loop break and continue functionality before SystemVerilog added the break and continue keywords.</p>

</dd>
<dt id="inside">inside</dt>
<dd>

<p>Inside expressions may not include unpacked array traversal or $ as an upper bound. Case inside and case matches are also unsupported.</p>

</dd>
<dt id="interface">interface</dt>
<dd>

<p>Interfaces and modports, including with generated data types are supported. Generate blocks around modports are not supported, nor are virtual interfaces nor unnamed interfaces.</p>

</dd>
<dt id="priority-if-unique-if">priority if, unique if</dt>
<dd>

<p>Priority and unique if&#39;s are treated as normal ifs and not asserted to be full nor unique.</p>

</dd>
<dt id="specify-specparam">specify specparam</dt>
<dd>

<p>All specify blocks and timing checks are ignored.</p>

</dd>
<dt id="string">string</dt>
<dd>

<p>String is supported only to the point that they can be assigned, concatenated, compared, and passed to DPI imports. Standard method calls on strings are not supported.</p>

</dd>
<dt id="timeunit-timeprecision">timeunit, timeprecision</dt>
<dd>

<p>All timing control statements are ignored.</p>

</dd>
<dt id="uwire">uwire</dt>
<dd>

<p>Verilator does not perform warning checking on uwires, it treats the uwire keyword as if it were the normal wire keyword.</p>

</dd>
<dt id="bits-countones-error-fatal-finish-info-isunknown-onehot-onehot0-readmemb-readmemh-signed-stime-stop-time-unsigned-warning">$bits, $countones, $error, $fatal, $finish, $info, $isunknown, $onehot, $onehot0, $readmemb, $readmemh, $signed, $stime, $stop, $time, $unsigned, $warning.</dt>
<dd>

<p>Generally supported.</p>

</dd>
<dt id="display-write-fdisplay-fwrite-swrite">$display, $write, $fdisplay, $fwrite, $swrite</dt>
<dd>

<p>$display and friends must have a constant format string as the first argument (as with C&#39;s printf). The rare usage which lists variables standalone without a format is not supported.</p>

</dd>
<dt id="displayb-displayh-displayo-writeb-writeh-writeo-etc">$displayb, $displayh, $displayo, $writeb, $writeh, $writeo, etc</dt>
<dd>

<p>The sized display functions are rarely used and so not supported. Replace them with a $write with the appropriate format specifier.</p>

</dd>
<dt id="finish-stop">$finish, $stop</dt>
<dd>

<p>The rarely used optional parameter to $finish and $stop is ignored.</p>

</dd>
<dt id="fopen-fclose-fdisplay-feof-fflush-fgetc-fgets-fscanf-fwrite">$fopen, $fclose, $fdisplay, $feof, $fflush, $fgetc, $fgets, $fscanf, $fwrite</dt>
<dd>

<p>File descriptors passed to the file PLI calls must be file descriptors, not MCDs, which includes the mode parameter to $fopen being mandatory.</p>

</dd>
<dt id="fscanf-sscanf">$fscanf, $sscanf</dt>
<dd>

<p>Only integer formats are supported; %e, %f, %m, %r, %v, and %z are not supported.</p>

</dd>
<dt id="fullskew-hold-nochange-period-recovery-recrem-removal-setup-setuphold-skew-timeskew-width">$fullskew, $hold, $nochange, $period, $recovery, $recrem, $removal, $setup, $setuphold, $skew, $timeskew, $width</dt>
<dd>

<p>All specify blocks and timing checks are ignored.</p>

</dd>
<dt id="random">$random</dt>
<dd>

<p>$random does not support the optional argument to set the seed. Use the srand function in C to accomplish this, and note there is only one random number generator (not one per module).</p>

</dd>
<dt id="readmemb-readmemh">$readmemb, $readmemh</dt>
<dd>

<p>Read memory commands should work properly. Note Verilator and the Verilog specification does not include support for readmem to multi-dimensional arrays.</p>

</dd>
<dt id="test-plusargs-value-plusargs">$test$plusargs, $value$plusargs</dt>
<dd>

<p>Supported, but the instantiating C++/SystemC testbench must call</p>

<pre><code>    Verilated::commandArgs(argc, argv);</code></pre>

<p>to register the command line before calling $test$plusargs or $value$plusargs.</p>

</dd>
<dt id="timeformat">$timeformat</dt>
<dd>

<p>Not supported as Verilator needs to determine all formatting at compile time. Generally you can just ifdef them out for no ill effect. Note also VL_TIME_MULTIPLER can be defined at compile time to move the decimal point when displaying all times, model wide.</p>

</dd>
</dl>

<h1 id="ERRORS-AND-WARNINGS">ERRORS AND WARNINGS</h1>

<p>Warnings may be disabled in three ways. First, when the warning is printed it will include a warning code. Simply surround the offending line with a warn_off/warn_on pair:</p>

<pre><code>        // verilator lint_off UNSIGNED
        if (`DEF_THAT_IS_EQ_ZERO &lt;= 3) $stop;
        // verilator lint_on UNSIGNED</code></pre>

<p>Second, warnings may be disabled using a configuration file with a lint_off command. This is useful when a script is suppressing warnings and the Verilog source should not be changed.</p>

<p>Warnings may also be globally disabled by invoking Verilator with the <code>-Wno-<i>warning</i></code> switch. This should be avoided, as it removes all checking across the designs, and prevents other users from compiling your code without knowing the magic set of disables needed to successfully compile your design.</p>

<p>List of all warnings:</p>

<dl>

<dt id="ALWCOMBORDER">ALWCOMBORDER</dt>
<dd>

<p>Warns that an always_comb block has a variable which is set after it is used. This may cause simulation-synthesis mismatches, as not all commercial simulators allow this ordering.</p>

<pre><code>    always_comb begin
       a = b;
       b = 1;
    end</code></pre>

<p>Ignoring this warning will only suppress the lint check, it will simulate correctly.</p>

</dd>
<dt id="ASSIGNIN">ASSIGNIN</dt>
<dd>

<p>Error that an assignment is being made to an input signal. This is almost certainly a mistake, though technically legal.</p>

<pre><code>    input a;
    assign a = 1&#39;b1;</code></pre>

<p>Ignoring this warning will only suppress the lint check, it will simulate correctly.</p>

</dd>
<dt id="ASSIGNDLY">ASSIGNDLY</dt>
<dd>

<p>Warns that you have an assignment statement with a delayed time in front of it, for example:</p>

<pre><code>    a &lt;= #100 b;
    assign #100 a = b;</code></pre>

<p>Ignoring this warning may make Verilator simulations differ from other simulators, however at one point this was a common style so disabled by default as a code style warning.</p>

</dd>
<dt id="BLKANDNBLK">BLKANDNBLK</dt>
<dd>

<p>BLKANDNBLK is an error that a variable comes from a mix of blocked and non-blocking assignments. Generally, this is caused by a register driven by both combo logic and a flop:</p>

<pre><code>      always @ (posedge clk)  foo[0] &lt;= ...
      always @* foo[1] = ...</code></pre>

<p>Simply use a different register for the flop:</p>

<pre><code>      always @ (posedge clk)  foo_flopped[0] &lt;= ...
      always @* foo[0] = foo_flopped[0];
      always @* foo[1] = ...</code></pre>

<p>This is not illegal in SystemVerilog, but a violation of good coding practice. Verilator reports this as an error, because ignoring this warning may make Verilator simulations differ from other simulators.</p>

<p>It is generally safe to disable this error (with a &quot;// verilator lint_off BLKANDNBLK&quot; metacomment or the -Wno-BLKANDNBLK option) when one of the assignments is inside a public task, or when the blocked and non-blocking assignments have non-overlapping bits and structure members.</p>

</dd>
<dt id="BLKSEQ">BLKSEQ</dt>
<dd>

<p>This indicates that a blocking assignment (=) is used in a sequential block. Generally non-blocking/delayed assignments (&lt;=) are used in sequential blocks, to avoid the possibility of simulator races. It can be reasonable to do this if the generated signal is used ONLY later in the same block, however this style is generally discouraged as it is error prone.</p>

<pre><code>      always @ (posedge clk)  foo = ...</code></pre>

<p>Disabled by default as this is a code style warning; it will simulate correctly.</p>

</dd>
<dt id="BLKLOOPINIT">BLKLOOPINIT</dt>
<dd>

<p>This indicates that the initialization of an array needs to use non-delayed assignments. This is done in the interest of speed; if delayed assignments were used, the simulator would have to copy large arrays every cycle. (In smaller loops, loop unrolling allows the delayed assignment to work, though it&#39;s a bit slower than a non-delayed assignment.) Here&#39;s an example</p>

<pre><code>        always @ (posedge clk)
            if (~reset_l) begin
                for (i=0; i&lt;`ARRAY_SIZE; i++) begin
                    array[i] = 0;  // Non-delayed for verilator
                end</code></pre>

<p>This message is only seen on large or complicated loops because Verilator generally unrolls small loops. You may want to try increasing --unroll-count (and occasionally --unroll-stmts) which will raise the small loop bar to avoid this error.</p>

</dd>
<dt id="BSSPACE">BSSPACE</dt>
<dd>

<p>Warns that a backslash is followed by a space then a newline. Likely the intent was to have a backslash directly followed by a newline (e.g. when making a `define) and there&#39;s accidentally whitespace at the end of the line. If the space is not accidental, suggest removing the backslash in the code as it serves no function.</p>

<p>Ignoring this warning will only suppress the lint check, it will simulate correctly.</p>

</dd>
<dt id="CASEINCOMPLETE">CASEINCOMPLETE</dt>
<dd>

<p>Warns that inside a case statement there is a stimulus pattern for which there is no case item specified. This is bad style, if a case is impossible, it&#39;s better to have a &quot;default: $stop;&quot; or just &quot;default: ;&quot; so that any design assumption violations will be discovered in simulation.</p>

<p>Ignoring this warning will only suppress the lint check, it will simulate correctly.</p>

</dd>
<dt id="CASEOVERLAP">CASEOVERLAP</dt>
<dd>

<p>Warns that inside a case statement you have case values which are detected to be overlapping. This is bad style, as moving the order of case values will cause different behavior. Generally the values can be respecified to not overlap.</p>

<p>Ignoring this warning will only suppress the lint check, it will simulate correctly.</p>

</dd>
<dt id="CASEX">CASEX</dt>
<dd>

<p>Warns that it is simply better style to use casez, and <code>?</code> in place of <code>x</code>&#39;s. See <a href="http://www.sunburst-design.com/papers/CummingsSNUG1999Boston_FullParallelCase_rev1_1.pdf">http://www.sunburst-design.com/papers/CummingsSNUG1999Boston_FullParallelCase_rev1_1.pdf</a></p>

<p>Ignoring this warning will only suppress the lint check, it will simulate correctly.</p>

</dd>
<dt id="CASEWITHX">CASEWITHX</dt>
<dd>

<p>Warns that a case statement contains a constant with a <code>x</code>. Verilator is two-state so interpret such items as always false. Note a common error is to use a <code>X</code> in a case or casez statement item; often what the user instead intended is to use a casez with <code>?</code>.</p>

<p>Ignoring this warning will only suppress the lint check, it will simulate correctly.</p>

</dd>
<dt id="CDCRSTLOGIC">CDCRSTLOGIC</dt>
<dd>

<p>With --cdc only, warns that asynchronous flop reset terms come from other than primary inputs or flopped outputs, creating the potential for reset glitches.</p>

</dd>
<dt id="CLKDATA">CLKDATA</dt>
<dd>

<p>Warns that clock signal is mixed used with/as data signal. The checking for this warning is enabled only if user has explicitly marked some signal as clocker using command line option or in-source meta comment (see <code>--clk</code>).</p>

<p>The warning can be disabled without affecting the simulation result. But it is recommended to check the warning as this may degrade the performance of the Verilated model.</p>

</dd>
<dt id="CMPCONST">CMPCONST</dt>
<dd>

<p>Warns that you are comparing a value in a way that will always be constant. For example &quot;X &gt; 1&quot; will always be true when X is a single bit wide.</p>

<p>Ignoring this warning will only suppress the lint check, it will simulate correctly.</p>

</dd>
<dt id="COLONPLUS">COLONPLUS</dt>
<dd>

<p>Warns that a :+ is seen. Likely the intent was to use +: to select a range of bits. If the intent was a range that is explicitly positive, suggest adding a space, e.g. use &quot;: +&quot;.</p>

<p>Ignoring this warning will only suppress the lint check, it will simulate correctly.</p>

</dd>
<dt id="COMBDLY">COMBDLY</dt>
<dd>

<p>Warns that you have a delayed assignment inside of a combinatorial block. Using delayed assignments in this way is considered bad form, and may lead to the simulator not matching synthesis. If this message is suppressed, Verilator, like synthesis, will convert this to a non-delayed assignment, which may result in logic races or other nasties. See <a href="http://www.sunburst-design.com/papers/CummingsSNUG2000SJ_NBA_rev1_2.pdf">http://www.sunburst-design.com/papers/CummingsSNUG2000SJ_NBA_rev1_2.pdf</a></p>

<p>Ignoring this warning may make Verilator simulations differ from other simulators.</p>

</dd>
<dt id="CONTASSREG">CONTASSREG</dt>
<dd>

<p>Error that a continuous assignment is setting a reg. According to IEEE Verilog, but not SystemVerilog, a wire must be used as the target of continuous assignments.</p>

<p>This error is only reported when &quot;--language 1364-1995&quot;, &quot;--language 1364-2001&quot;, or &quot;--language 1364-2005&quot; is used.</p>

<p>Ignoring this error will only suppress the lint check, it will simulate correctly.</p>

</dd>
<dt id="DECLFILENAME">DECLFILENAME</dt>
<dd>

<p>Warns that a module or other declaration&#39;s name doesn&#39;t match the filename with path and extension stripped that it is declared in. The filename a modules/interfaces/programs is declared in should match the name of the module etc. so that -y directory searching will work. This warning is printed for only the first mismatching module in any given file, and -v library files are ignored.</p>

<p>Disabled by default as this is a code style warning; it will simulate correctly.</p>

</dd>
<dt id="DEFPARAM">DEFPARAM</dt>
<dd>

<p>Warns that the &quot;defparam&quot; statement was deprecated in Verilog 2001 and all designs should now be using the #(...) format to specify parameters.</p>

<p>Disabled by default as this is a code style warning; it will simulate correctly.</p>

</dd>
<dt id="DETECTARRAY">DETECTARRAY</dt>
<dd>

<p>Error when Verilator tries to deal with a combinatorial loop that could not be flattened, and which involves a datatype which Verilator cannot handle, such as an unpacked struct or a large unpacked array. This typically ocurrs when -Wno-UNOPTFLAT has been used to override an UNOPTFLAT warning (see below).</p>

<p>The solution is to break the loop, as described for UNOPTFLAT.</p>

</dd>
<dt id="ENDLABEL">ENDLABEL</dt>
<dd>

<p>Warns that a label attached to a &quot;end&quot;-something statement does not match the label attached to the block start.</p>

<p>Ignoring this warning will only suppress the lint check, it will simulate correctly.</p>

</dd>
<dt id="GENCLK">GENCLK</dt>
<dd>

<p>Warns that the specified signal is generated, but is also being used as a clock. Verilator needs to evaluate sequential logic multiple times in this situation. In somewhat contrived cases having any generated clock can reduce performance by almost a factor of two. For fastest results, generate ALL clocks outside in C++/SystemC and make them primary inputs to your Verilog model. (However once need to you have even one, don&#39;t sweat additional ones.)</p>

<p>Ignoring this warning may make Verilator simulations differ from other simulators.</p>

</dd>
<dt id="IFDEPTH">IFDEPTH</dt>
<dd>

<p>Warns that if/if else statements have exceeded the depth specified with --if-depth, as they are likely to result in slow priority encoders. Unique and priority if statements are ignored. Solutions include changing the code to a case statement, or a SystemVerilog &#39;unique if&#39; or &#39;priority if&#39;.</p>

<p>Disabled by default as this is a code style warning; it will simulate correctly.</p>

</dd>
<dt id="IGNOREDRETURN">IGNOREDRETURN</dt>
<dd>

<p>Warns that a non-void function is being called as a task, and hence the return value is being ignored.</p>

<p>This warning is required by IEEE. The portable way to suppress this warning (in SystemVerilog) is to use a void cast, e.g.</p>

<pre><code>    void&#39;(function_being_called_as_task());</code></pre>

<p>Ignoring this warning will only suppress the lint check, it will simulate correctly.</p>

</dd>
<dt id="IMPERFECTSCH">IMPERFECTSCH</dt>
<dd>

<p>Warns that the scheduling of the model is not absolutely perfect, and some manual code edits may result in faster performance. This warning defaults to off, is not part of -Wall, and must be turned on explicitly before the top module statement is processed.</p>

</dd>
<dt id="IMPLICIT">IMPLICIT</dt>
<dd>

<p>Warns that a wire is being implicitly declared (it is a single bit wide output from a sub-module.) While legal in Verilog, implicit declarations only work for single bit wide signals (not buses), do not allow using a signal before it is implicitly declared by a cell, and can lead to dangling nets. A better option is the /*AUTOWIRE*/ feature of Verilog-Mode for Emacs, available from <a href="http://www.veripool.org/">http://www.veripool.org/</a></p>

<p>Ignoring this warning will only suppress the lint check, it will simulate correctly.</p>

</dd>
<dt id="IMPORTSTAR">IMPORTSTAR</dt>
<dd>

<p>Warns that an &quot;import <i>package</i>::*&quot; statement is in $unit scope. This causes the imported symbols to polute the global namespace, defeating much of the purpose of having a package. Generally &quot;import ::*&quot; should only be used inside a lower scope such as a package or module.</p>

<p>Disabled by default as this is a code style warning; it will simulate correctly.</p>

</dd>
<dt id="IMPURE">IMPURE</dt>
<dd>

<p>Warns that a task or function that has been marked with /*verilator no_inline_task*/ references variables that are not local to the task. Verilator cannot schedule these variables correctly.</p>

<p>Ignoring this warning may make Verilator simulations differ from other simulators.</p>

</dd>
<dt id="INCABSPATH">INCABSPATH</dt>
<dd>

<p>Warns that an `include filename specifies an absolute path. This means the code will not work on any other system with a different file system layout. Instead of using absolute paths, relative paths (preferably without any directory specified whatever) should be used, and +incdir used on the command line to specify the top include source directories.</p>

<p>Disabled by default as this is a code style warning; it will simulate correctly.</p>

</dd>
<dt id="INFINITELOOP">INFINITELOOP</dt>
<dd>

<p>Warns that a while or for statement has a condition that is always true. and thus result in an infinite loop if the statement ever executes.</p>

<p>This might be unintended behavior if the loop body contains statements that in other statements that would make time pass, which Verilator is ignoring due to e.g. STMTDLY warnings being disabled.</p>

<p>Ignoring this warning will only suppress the lint check, it will simulate correctly (i.e. hang due to the infinite loop).</p>

</dd>
<dt id="INITIALDLY">INITIALDLY</dt>
<dd>

<p>Warns that you have a delayed assignment inside of an initial or final block. If this message is suppressed, Verilator will convert this to a non-delayed assignment. See also the COMBDLY warning.</p>

<p>Ignoring this warning may make Verilator simulations differ from other simulators.</p>

</dd>
<dt id="LITENDIAN">LITENDIAN</dt>
<dd>

<p>Warns that a packed vector is declared with little endian bit numbering (i.e. [0:7]). Big endian bit numbering is now the overwhelming standard, and little numbering is now thus often due to simple oversight instead of intent.</p>

<p>Also warns that a cell is declared with little endian range (i.e. [0:7] or [7]) and is connected to a N-wide signal. Based on IEEE the bits will likely be backwards from what you expect (i.e. cell [0] will connect to signal bit [N-1] not bit [0]).</p>

<p>Ignoring this warning will only suppress the lint check, it will simulate correctly.</p>

</dd>
<dt id="MODDUP">MODDUP</dt>
<dd>

<p>Warns that a module has multiple definitions. Generally this indicates a coding error, or a mistake in a library file and it&#39;s good practice to have one module per file (and only put each file once on the command line) to avoid these issues. For some gate level netlists duplicates are sometimes unavoidable, and MODDUP should be disabled.</p>

<p>Ignoring this warning will cause the more recent module definition to be discarded.</p>

</dd>
<dt id="MULTIDRIVEN">MULTIDRIVEN</dt>
<dd>

<p>Warns that the specified signal comes from multiple always blocks. This is often unsupported by synthesis tools, and is considered bad style. It will also cause longer runtimes due to reduced optimizations.</p>

<p>Ignoring this warning will only slow simulations, it will simulate correctly.</p>

</dd>
<dt id="MULTITOP">MULTITOP</dt>
<dd>

<p>Error that there are multiple top level modules, that is modules not instantiated by any other module. Verilator only supports a single top level, if you need more, create a module that wraps all of the top modules.</p>

<p>Often this error is because some low level cell is being read in, but is not really needed. The best solution is to insure that each module is in a unique file by the same name. Otherwise, make sure all library files are read in as libraries with -v, instead of automatically with -y.</p>

</dd>
<dt id="PINCONNECTEMPTY">PINCONNECTEMPTY</dt>
<dd>

<p>Warns that a cell instantiation has a pin which is connected to .pin_name(), e.g. not another signal, but with an explicit mention of the pin. It may be desirable to disable PINCONNECTEMPTY, as this indicates intention to have a no-connect.</p>

<p>Disabled by default as this is a code style warning; it will simulate correctly.</p>

</dd>
<dt id="PINMISSING">PINMISSING</dt>
<dd>

<p>Warns that a module has a pin which is not mentioned in a cell instantiation. If a pin is not missing it should still be specified on the cell declaration with a empty connection, using &quot;(.pin_name())&quot;.</p>

<p>Ignoring this warning will only suppress the lint check, it will simulate correctly.</p>

</dd>
<dt id="PINNOCONNECT">PINNOCONNECT</dt>
<dd>

<p>Warns that a cell instantiation has a pin which is not connected to another signal.</p>

<p>Disabled by default as this is a code style warning; it will simulate correctly.</p>

</dd>
<dt id="PROCASSWIRE">PROCASSWIRE</dt>
<dd>

<p>Error that a procedural assignment is setting a wire. According to IEEE, a var/reg must be used as the target of procedural assignments.</p>

</dd>
<dt id="REALCVT">REALCVT</dt>
<dd>

<p>Warns that a real number is being implicitly rounded to an integer, with possible loss of precision.</p>

</dd>
<dt id="REDEFMACRO">REDEFMACRO</dt>
<dd>

<p>Warns that you have redefined the same macro with a different value, for example:</p>

<pre><code>    `define MACRO def1
    //...
    `define MACRO otherdef</code></pre>

<p>The best solution is to use a different name for the second macro. If this is not possible, add a undef to indicate the code is overriding the value:</p>

<pre><code>    `define MACRO def1
    //...
    `undef MACRO
    `define MACRO otherdef</code></pre>

</dd>
<dt id="SELRANGE">SELRANGE</dt>
<dd>

<p>Warns that a selection index will go out of bounds:</p>

<pre><code>    wire vec[6:0];
    initial out = vec[7];  // There is no 7</code></pre>

<p>Verilator will assume zero for this value, instead of X. Note that in some cases this warning may be false, when a condition upstream or downstream of the access means the access out of bounds will never execute or be used.</p>

<pre><code>    wire vec[6:0];
    initial begin
        seven = 7;
        ...
        if (seven != 7) out = vec[seven];  // Never will use vec[7]</code></pre>

</dd>
<dt id="STMTDLY">STMTDLY</dt>
<dd>

<p>Warns that you have a statement with a delayed time in front of it, for example:</p>

<pre><code>    #100 $finish;</code></pre>

<p>Ignoring this warning may make Verilator simulations differ from other simulators.</p>

</dd>
<dt id="SYMRSVDWORD">SYMRSVDWORD</dt>
<dd>

<p>Warning that a symbol matches a C++ reserved word and using this as a symbol name would result in odd C compiler errors. You may disable this warning, but the symbol will be renamed by Verilator to avoid the conflict.</p>

</dd>
<dt id="SYNCASYNCNET">SYNCASYNCNET</dt>
<dd>

<p>Warns that the specified net is used in at least two different always statements with posedge/negedges (i.e. a flop). One usage has the signal in the sensitivity list and body, probably as an async reset, and the other usage has the signal only in the body, probably as a sync reset. Mixing sync and async resets is usually a mistake. The warning may be disabled with a lint_off pragma around the net, or either flopped block.</p>

<p>Disabled by default as this is a code style warning; it will simulate correctly.</p>

</dd>
<dt id="TASKNSVAR">TASKNSVAR</dt>
<dd>

<p>Error when a call to a task or function has a output from that task tied to a non-simple signal. Instead connect the task output to a temporary signal of the appropriate width, and use that signal to set the appropriate expression as the next statement. For example:</p>

<pre><code>      task foo; output sig; ... endtask
      always @* begin
           foo(bus_we_select_from[2]);  // Will get TASKNSVAR error
      end</code></pre>

<p>Change this to:</p>

<pre><code>      reg foo_temp_out;
      always @* begin
           foo(foo_temp_out);
           bus_we_select_from[2] = foo_temp_out;
      end</code></pre>

<p>Verilator doesn&#39;t do this conversion for you, as some more complicated cases would result in simulator mismatches.</p>

</dd>
<dt id="TICKCOUNT">TICKCOUNT</dt>
<dd>

<p>Warns that the number of ticks to delay a $past variable is greater than 10. At present Verilator effectively creates a flop for each delayed signals, and as such any large counts may lead to large design size increases.</p>

<p>Ignoring this warning will only slow simulations, it will simulate correctly.</p>

</dd>
<dt id="UNDRIVEN">UNDRIVEN</dt>
<dd>

<p>Warns that the specified signal is never sourced. Verilator is fairly liberal in the usage calculations; making a signal public, or loading only a single array element marks the entire signal as driven.</p>

<p>Disabled by default as this is a code style warning; it will simulate correctly.</p>

</dd>
<dt id="UNOPT">UNOPT</dt>
<dd>

<p>Warns that due to some construct, optimization of the specified signal or block is disabled. The construct should be cleaned up to improve runtime.</p>

<p>A less obvious case of this is when a module instantiates two submodules. Inside submodule A, signal I is input and signal O is output. Likewise in submodule B, signal O is an input and I is an output. A loop exists and a UNOPT warning will result if AI &amp; AO both come from and go to combinatorial blocks in both submodules, even if they are unrelated always blocks. This affects performance because Verilator would have to evaluate each submodule multiple times to stabilize the signals crossing between the modules.</p>

<p>Ignoring this warning will only slow simulations, it will simulate correctly.</p>

</dd>
<dt id="UNOPTFLAT">UNOPTFLAT</dt>
<dd>

<p>Warns that due to some construct, optimization of the specified signal is disabled. The signal specified includes a complete scope to the signal; it may be only one particular usage of a multiply instantiated block. The construct should be cleaned up to improve runtime; two times better performance may be possible by fixing these warnings.</p>

<p>Unlike the UNOPT warning, this occurs after netlist flattening, and indicates a more basic problem, as the less obvious case described under UNOPT does not apply.</p>

<p>Often UNOPTFLAT is caused by logic that isn&#39;t truly circular as viewed by synthesis which analyzes interconnection per-bit, but is circular to simulation which analyzes per-bus:</p>

<pre><code>      wire [2:0] x = {x[1:0], shift_in};</code></pre>

<p>This statement needs to be evaluated multiple times, as a change in &quot;shift_in&quot; requires &quot;x&quot; to be computed 3 times before it becomes stable. This is because a change in &quot;x&quot; requires &quot;x&quot; itself to change value, which causes the warning.</p>

<p>For significantly better performance, split this into 2 separate signals:</p>

<pre><code>      wire [2:0] xout = {x[1:0], shift_in};</code></pre>

<p>and change all receiving logic to instead receive &quot;xout&quot;. Alternatively, change it to</p>

<pre><code>      wire [2:0] x = {xin[1:0], shift_in};</code></pre>

<p>and change all driving logic to instead drive &quot;xin&quot;.</p>

<p>With this change this assignment needs to be evaluated only once. These sort of changes may also speed up your traditional event driven simulator, as it will result in fewer events per cycle.</p>

<p>The most complicated UNOPTFLAT path we&#39;ve seen was due to low bits of a bus being generated from an always statement that consumed high bits of the same bus processed by another series of always blocks. The fix is the same; split it into two separate signals generated from each block.</p>

<p>The UNOPTFLAT warning may also be due to clock enables, identified from the reported path going through a clock gating cell. To fix these, use the clock_enable meta comment described above.</p>

<p>The UNOPTFLAT warning may also occur where outputs from a block of logic are independent, but occur in the same always block. To fix this, use the isolate_assignments meta comment described above.</p>

<p>To assist in resolving UNOPTFLAT, the option <code>--report-unoptflat</code> can be used, which will provide suggestions for variables that can be split up, and a graph of all the nodes connected in the loop. See the <a>Arguments</a> section for more details.</p>

<p>Ignoring this warning will only slow simulations, it will simulate correctly.</p>

</dd>
<dt id="UNOPTTHREADS">UNOPTTHREADS</dt>
<dd>

<p>Warns that the thread scheduler was unable to partition the design to fill the requested number of threads.</p>

<p>One workaround is to request fewer threads with <code>--threads</code>.</p>

<p>Another possible workaround is to allow more MTasks in the runtime, by increasing the value of --threads-max-mtasks. More MTasks will result in more communication and synchronization overhead at runtime; the scheduler attempts to minimize the number of MTasks for this reason.</p>

<p>Ignoring this warning will only slow simulations, it will simulate correctly.</p>

</dd>
<dt id="UNPACKED">UNPACKED</dt>
<dd>

<p>Warns that unpacked structs and unions are not supported.</p>

<p>Ignoring this warning will make Verilator treat the structure as packed, which may make Verilator simulations differ from other simulators.</p>

</dd>
<dt id="UNSIGNED">UNSIGNED</dt>
<dd>

<p>Warns that you are comparing a unsigned value in a way that implies it is signed, for example &quot;X &lt; 0&quot; will always be true when X is unsigned.</p>

<p>Ignoring this warning will only suppress the lint check, it will simulate correctly.</p>

</dd>
<dt id="UNUSED">UNUSED</dt>
<dd>

<p>Warns that the specified signal is never sinked. Verilator is fairly liberal in the usage calculations; making a signal public, a signal matching --unused-regexp (&quot;*unused*&quot;) or accessing only a single array element marks the entire signal as used.</p>

<p>Disabled by default as this is a code style warning; it will simulate correctly.</p>

<p>A recommended style for unused nets is to put at the bottom of a file code similar to the following:</p>

<pre><code>    wire _unused_ok = &amp;{1&#39;b0,
                        sig_not_used_a,
                        sig_not_used_yet_b,  // To be fixed
                        1&#39;b0};</code></pre>

<p>The reduction AND and constant zeros mean the net will always be zero, so won&#39;t use simulation time. The redundant leading and trailing zeros avoid syntax errors if there are no signals between them. The magic name &quot;unused&quot; (-unused-regexp) is recognized by Verilator and suppresses warnings; if using other lint tools, either teach to tool to ignore signals with &quot;unused&quot; in the name, or put the appropriate lint_off around the wire. Having unused signals in one place makes it easy to find what is unused, and reduces the number of lint_off pragmas, reducing bugs.</p>

</dd>
<dt id="USERINFO-USERWARN-USERERROR-USERFATAL">USERINFO, USERWARN, USERERROR, USERFATAL</dt>
<dd>

<p>A SystemVerilog elaboration-time assertion print was executed.</p>

</dd>
<dt id="VARHIDDEN">VARHIDDEN</dt>
<dd>

<p>Warns that a task, function, or begin/end block is declaring a variable by the same name as a variable in the upper level module or begin/end block (thus hiding the upper variable from being able to be used.) Rename the variable to avoid confusion when reading the code.</p>

<p>Disabled by default as this is a code style warning; it will simulate correctly.</p>

</dd>
<dt id="WIDTH">WIDTH</dt>
<dd>

<p>Warns that based on width rules of Verilog, two operands have different widths. Verilator generally can intuit the common usages of widths, and you shouldn&#39;t need to disable this message like you do with most lint programs. Generally other than simple mistakes, you have two solutions:</p>

<p>If it&#39;s a constant 0 that&#39;s 32 bits or less, simply leave it unwidthed. Verilator considers zero to be any width needed.</p>

<p>Concatenate leading zeros when doing arithmetic. In the statement</p>

<pre><code>        wire [5:0] plus_one = from[5:0] + 6&#39;d1 + carry[0];</code></pre>

<p>The best fix, which clarifies intent and will also make all tools happy is:</p>

<pre><code>        wire [5:0] plus_one = from[5:0] + 6&#39;d1 + {5&#39;d0, carry[0]};</code></pre>

<p>Ignoring this warning will only suppress the lint check, it will simulate correctly.</p>

</dd>
<dt id="WIDTHCONCAT">WIDTHCONCAT</dt>
<dd>

<p>Warns that based on width rules of Verilog, a concatenate or replication has an indeterminate width. In most cases this violates the Verilog rule that widths inside concatenates and replicates must be sized, and should be fixed in the code.</p>

<pre><code>    wire [63:0] concat = {1, 2};</code></pre>

<p>An example where this is technically legal (though still bad form) is:</p>

<pre><code>    parameter PAR = 1;
    wire [63:0] concat = {PAR, PAR};</code></pre>

<p>The correct fix is to either size the 1 (&quot;32&#39;h1&quot;), or add the width to the parameter definition (&quot;parameter [31:0]&quot;), or add the width to the parameter usage (&quot;{PAR[31:0],PAR[31:0]}&quot;.</p>

</dd>
</dl>

<p>The following describes the less obvious errors:</p>

<dl>

<dt id="Internal-Error">Internal Error</dt>
<dd>

<p>This error should never occur first, though may occur if earlier warnings or error messages have corrupted the program. If there are no other warnings or errors, submit a bug report.</p>

</dd>
<dt id="Unsupported">Unsupported: ....</dt>
<dd>

<p>This error indicates that you are using a Verilog language construct that is not yet supported in Verilator. See the Limitations chapter.</p>

</dd>
<dt id="Verilated-model-didnt-converge">Verilated model didn&#39;t converge</dt>
<dd>

<p>Verilator sometimes has to evaluate combinatorial logic multiple times, usually around code where a UNOPTFLAT warning was issued, but disabled. For example:</p>

<pre><code>   always @ (a)  b=~a;
   always @ (b)  a=b</code></pre>

<p>will toggle forever and thus the executable will give the didn&#39;t converge error to prevent an infinite loop.</p>

<p>To debug this, first is to review any UNOPTFLAT warnings that were ignored, though typically these can be ignored (at a performance cost), convergence issues can also be flagged with this warning as Verilator didn&#39;t know if they would eventually converge.</p>

<p>Next, run Verilator with --prof-cfuncs. Run make on the generated files with &quot;OPT=-DVL_DEBUG&quot;. Then call Verilated::debug(1) in your main.cpp.</p>

<p>This will cause each change in a variable to print a message. Near the bottom you&#39;ll see the variables that causes the problem. For the program above:</p>

<pre><code>        CHANGE: filename.v:1: b
        CHANGE: filename.v:2: a</code></pre>

<p>If many signals are getting printed then most likely each are oscillating (or there is a bug). It may also be that e.g. &quot;a&quot; may be oscillating, then &quot;a&quot; feeds signal &quot;c&quot; which then is also reported as oscillating.</p>

<p>Finally, rare more difficult cases can be debugged like a &quot;C&quot; program; either enter GDB and use its tracing facilities, or edit the generated C++ code to add appropriate prints to see what is going on.</p>

</dd>
</dl>

<h1 id="FAQ-FREQUENTLY-ASKED-QUESTIONS">FAQ/FREQUENTLY ASKED QUESTIONS</h1>

<dl>

<dt id="Does-it-run-under-Windows">Does it run under Windows?</dt>
<dd>

<p>Yes, using Cygwin. Verilated output also compiles under Microsoft Visual C++ Version 7 or newer, but this is not tested every release.</p>

</dd>
<dt id="Can-you-provide-binaries">Can you provide binaries?</dt>
<dd>

<p>Verilator is available as a RPM for Debian/Ubuntu, SuSE, Fedora, and perhaps other systems; this is done by porters and may slightly lag the primary distribution. If there isn&#39;t a binary build for your distribution, how about you set one up? Please contact the authors for assistance.</p>

<p>Note people sometimes request binaries when they are having problems with their C++ compiler. Alas, binaries won&#39;t help this, as in the end a fully working C++ compiler is required to compile the output of Verilator.</p>

</dd>
<dt id="How-can-it-be-faster-than-name-the-commercial-simulator">How can it be faster than (name-the-commercial-simulator)?</dt>
<dd>

<p>Generally, the implied part is of the question is &quot;... with all of the manpower they can put into developing it.&quot;</p>

<p>Most commercial simulators have to be Verilog compliant, meaning event driven. This prevents them from being able to reorder blocks and make netlist-style optimizations, which are where most of the gains come from.</p>

<p>Non-compliance shouldn&#39;t be scary. Your synthesis program isn&#39;t compliant, so your simulator shouldn&#39;t have to be -- and Verilator is closer to the synthesis interpretation, so this is a good thing for getting working silicon.</p>

</dd>
<dt id="Will-Verilator-output-remain-under-my-own-license">Will Verilator output remain under my own license?</dt>
<dd>

<p>Yes, it&#39;s just like using GCC on your programs; this is why Verilator uses the &quot;GNU *Lesser* Public License Version 3&quot; instead of the more typical &quot;GNU Public License&quot;. See the licenses for details, but in brief, if you change Verilator itself or the header files Verilator includes, you must make the source code available under the GNU Lesser Public License. However, Verilator output (the Verilated code) only &quot;include&quot;s the licensed files, and so you are NOT required to release any output from Verilator.</p>

<p>You also have the option of using the Perl Artistic License, which again does not require you release your Verilog or generated code, and also allows you to modify Verilator for internal use without distributing the modified version. But please contribute back to the community!</p>

<p>One limit is that you cannot under either license release a commercial Verilog simulation product incorporating Verilator without making the source code available.</p>

<p>As is standard with Open Source, contributions back to Verilator will be placed under the Verilator copyright and LGPL/Artistic license. Small test cases will be released into the public domain so they can be used anywhere, and large tests under the LGPL/Artistic, unless requested otherwise.</p>

</dd>
<dt id="Why-is-Verilation-so-slow">Why is Verilation so slow?</dt>
<dd>

<p>Verilator needs more memory than the resulting simulator will require, as Verilator creates internally all of the state of the resulting generated simulator in order to optimize it. If it takes more than a minute or so (and you&#39;re not using --debug since debug is disk bound), see if your machine is paging; most likely you need to run it on a machine with more memory. Verilator is a full 64-bit application and may use more than 4GB, but about 1GB is the maximum typically needed, and very large commercial designs have topped 16GB.</p>

</dd>
<dt id="How-do-I-generate-waveforms-traces-in-C">How do I generate waveforms (traces) in C++?</dt>
<dd>

<p>See the next question for tracing in SystemC mode.</p>

<p>Add the --trace switch to Verilator, and in your top level C code, call Verilated::traceEverOn(true). Then create a VerilatedVcdC object, and in your main loop call &quot;trace_object-&gt;dump(time)&quot; every time step, and finally call &quot;trace_object-&gt;close()&quot;. For an example, see below and the examples/tracing_c/sim_main.cpp file of the distribution.</p>

<p>You also need to compile verilated_vcd_c.cpp and add it to your link, preferably by adding the dependencies in $(VK_GLOBAL_OBJS) to your Makefile&#39;s link rule. This is done for you if using the Verilator --exe flag.</p>

<p>Note you can also call -&gt;trace on multiple Verilated objects with the same trace file if you want all data to land in the same output file.</p>

<pre><code>    #include &quot;verilated_vcd_c.h&quot;
    ...
    int main(int argc, char** argv, char** env) {
        ...
        Verilated::traceEverOn(true);
        VerilatedVcdC* tfp = new VerilatedVcdC;
        topp-&gt;trace(tfp, 99);  // Trace 99 levels of hierarchy
        tfp-&gt;open(&quot;obj_dir/t_trace_ena_cc/simx.vcd&quot;);
        ...
        while (sc_time_stamp() &lt; sim_time &amp;&amp; !Verilated::gotFinish()) {
            main_time += #;
            tfp-&gt;dump(main_time);
        }
        tfp-&gt;close();
    }</code></pre>

</dd>
<dt id="How-do-I-generate-waveforms-traces-in-SystemC">How do I generate waveforms (traces) in SystemC?</dt>
<dd>

<p>Add the --trace switch to Verilator, and in your top level C sc_main code, include verilated_vcd_sc.h. Then call Verilated::traceEverOn(true). Then create a VerilatedVcdSc object as you would create a normal SystemC trace file. For an example, see the call to VerilatedVcdSc in the examples/tracing_sc/sc_main.cpp file of the distribution, and below.</p>

<p>Alternatively you may use the C++ trace mechanism described in the previous question, however the timescale and timeprecision will not inherited from your SystemC settings.</p>

<p>You also need to compile verilated_vcd_sc.cpp and verilated_vcd_c.cpp and add them to your link, preferably by adding the dependencies in $(VK_GLOBAL_OBJS) to your Makefile&#39;s link rule. This is done for you if using the Verilator --exe flag.</p>

<p>Note you can also call -&gt;trace on multiple Verilated objects with the same trace file if you want all data to land in the same output file.</p>

<pre><code>    #include &quot;verilated_vcd_sc.h&quot;
    ...
    int main(int argc, char** argv, char** env) {
        ...
        Verilated::traceEverOn(true);
        VerilatedVcdSc* tfp = new VerilatedVcdSc;
        topp-&gt;trace(tfp, 99);  // Trace 99 levels of hierarchy
        tfp-&gt;open(&quot;obj_dir/t_trace_ena_cc/simx.vcd&quot;);
        ...
        sc_start(1);
        ...
        tfp-&gt;close();
    }</code></pre>

</dd>
<dt id="How-do-I-generate-FST-waveforms-traces-in-C">How do I generate FST waveforms (traces) in C++?</dt>
<dd>

<p>FST a format by GTKWave. This version provides a basic FST support. To dump FST format, add the --trace-fst switch to Verilator and change the include path in the testbench to:</p>

<pre><code>    #include &quot;verilated_fst_c.h&quot;
    VerilatedFstC* tfp = new VerilatedFstC;</code></pre>

<p>Note that currently supporting both FST and VCD in a single simulation is impossible, but such requirement could be rare.</p>

</dd>
<dt id="How-do-I-generate-FST-waveforms-traces-in-SystemC">How do I generate FST waveforms (traces) in SystemC?</dt>
<dd>

<p>The FST library from GTKWave does not currently support SystemC; use VCD format instead.</p>

</dd>
<dt id="How-do-I-view-waveforms-traces">How do I view waveforms (traces)?</dt>
<dd>

<p>Verilator makes standard VCD (Value Change Dump) and FST files. VCD files are viewable with the public domain GTKWave (recommended) or Dinotrace (legacy) programs, or any of the many commercial offerings; FST is supported by GTKWave only.</p>

</dd>
<dt id="How-do-I-reduce-the-size-of-large-waveform-trace-files">How do I reduce the size of large waveform (trace) files?</dt>
<dd>

<p>First, instead of calling VerilatedVcdC-&gt;open at the beginning of time, delay calling it until the time stamp where you want to tracing to begin. Likewise you can also call VerilatedVcdC-&gt;open before the end of time (perhaps a short period after you detect a verification error.)</p>

<p>Next, add /*verilator tracing_off*/ to any very low level modules you never want to trace (such as perhaps library cells). Finally, use the --trace-depth option to limit the depth of tracing, for example --trace-depth 1 to see only the top level signals.</p>

<p>Also be sure you write your trace files to a local solid-state disk, instead of to a network disk. Network disks are generally far slower.</p>

</dd>
<dt id="How-do-I-do-coverage-analysis">How do I do coverage analysis?</dt>
<dd>

<p>Verilator supports both block (line) coverage and user inserted functional coverage.</p>

<p>First, run verilator with the --coverage option. If you&#39;re using your own makefile, compile the model with the GCC flag -DVM_COVERAGE (if using Verilator&#39;s, it will do this for you.)</p>

<p>At the end of your test, call VerilatedCov::write passing the name of the coverage data file (typically &quot;logs/coverage.dat&quot;).</p>

<p>Run each of your tests in different directories. Each test will create a logs/coverage.dat file.</p>

<p>After running all of your tests, verilator_coverage is executed. Verilator_coverage reads the logs/coverage.dat file(s), and creates an annotated source code listing showing code coverage details.</p>

<p>For an example, after running &#39;make test&#39; in the Verilator distribution, see the examples/tracing_c/logs directory. Grep for lines starting with &#39;%&#39; to see what lines Verilator believes need more coverage.</p>

</dd>
<dt id="Where-is-the-translate_off-command-How-do-I-ignore-a-construct">Where is the translate_off command? (How do I ignore a construct?)</dt>
<dd>

<p>Translate on/off pragmas are generally a bad idea, as it&#39;s easy to have mismatched pairs, and you can&#39;t see what another tool sees by just preprocessing the code. Instead, use the preprocessor; Verilator defines the &quot;VERILATOR&quot; define for you, so just wrap the code in an ifndef region:</p>

<pre><code>   `ifndef VERILATOR
      Something_Verilator_Dislikes;
   `endif</code></pre>

<p>Most synthesis tools similarly define SYNTHESIS for you.</p>

</dd>
<dt id="Why-do-I-get-unexpected-do-or-unexpected-bit-errors">Why do I get &quot;unexpected `do&#39;&quot; or &quot;unexpected `bit&#39;&quot; errors?</dt>
<dd>

<p>Do, bit, ref, return, and other words are now SystemVerilog keywords. You should change your code to not use them to insure it works with newer tools. Alternatively, surround them by the Verilog 2005/SystemVerilog begin_keywords pragma to indicate Verilog 2001 code.</p>

<pre><code>   `begin_keywords &quot;1364-2001&quot;
      integer bit; initial bit = 1;
   `end_keywords</code></pre>

<p>If you want the whole file to be parsed as Verilog 2001, just create a file with</p>

<pre><code>   `begin_keywords &quot;1364-2001&quot;</code></pre>

<p>and add it before other Verilog files on the command line. (Note this will also change the default for --prefix, so if you&#39;re not using --prefix, you will now need to.)</p>

</dd>
<dt id="How-do-I-prevent-my-assertions-from-firing-during-reset">How do I prevent my assertions from firing during reset?</dt>
<dd>

<p>Call Verilated::assertOn(false) before you first call the model, then turn it back on after reset. It defaults to true. When false, all assertions controlled by --assert are disabled.</p>

</dd>
<dt id="Why-do-I-get-undefined-reference-to-sc_time_stamp">Why do I get &quot;undefined reference to `sc_time_stamp()&#39;&quot;?</dt>
<dd>

<p>In C++ (non SystemC) code you need to define this function so that the simulator knows the current time. See the &quot;CONNECTING TO C++&quot; examples.</p>

</dd>
<dt id="Why-do-I-get-undefined-reference-to-VL_RAND_RESET_I-or-Verilated">Why do I get &quot;undefined reference to `VL_RAND_RESET_I&#39; or `Verilated::...&#39;&quot;?</dt>
<dd>

<p>You need to link your compiled Verilated code against the verilated.cpp file found in the include directory of the Verilator kit. This is one target in the $(VK_GLOBAL_OBJS) make variable, which should be part of your Makefile&#39;s link rule. If you use --exe, this is done for you.</p>

</dd>
<dt id="Is-the-PLI-supported">Is the PLI supported?</dt>
<dd>

<p>Only somewhat. More specifically, the common PLI-ish calls $display, $finish, $stop, $time, $write are converted to C++ equivalents. You can also use the &quot;import DPI&quot; SystemVerilog feature to call C code (see the chapter above). There is also limited VPI access to public signals.</p>

<p>If you want something more complex, since Verilator emits standard C++ code, you can simply write your own C++ routines that can access and modify signal values without needing any PLI interface code, and call it with $c(&quot;{any_c++_statement}&quot;).</p>

</dd>
<dt id="How-do-I-make-a-Verilog-module-that-contain-a-C-object">How do I make a Verilog module that contain a C++ object?</dt>
<dd>

<p>You need to add the object to the structure that Verilator creates, then use $c to call a method inside your object. The test_regress/t/t_extend_class files show an example of how to do this.</p>

</dd>
<dt id="How-do-I-get-faster-build-times">How do I get faster build times?</dt>
<dd>

<p>Use a recent compiler. Newer compilers tend do be faster, with the now relatively old GCC 3.0 to 3.3 being horrible.</p>

<p>Compile in parallel on many machines and use caching; see the web for the ccache, distcc and icecream packages. ccache will skip GCC runs between identical source builds, even across different users. You can use the OBJCACHE environment variable to use these CC wrappers. Also see the --output-split option.</p>

<p>To reduce the compile time of classes that use a Verilated module (e.g. a top CPP file) you may wish to add /*verilator no_inline_module*/ to your top level module. This will decrease the amount of code in the model&#39;s Verilated class, improving compile times of any instantiating top level C++ code, at a relatively small cost of execution performance.</p>

</dd>
<dt id="Why-do-so-many-files-need-to-recompile-when-I-add-a-signal">Why do so many files need to recompile when I add a signal?</dt>
<dd>

<p>Adding a new signal requires the symbol table to be recompiled. Verilator uses one large symbol table, as that results in 2-3 less assembly instructions for each signal access. This makes the execution time 10-15% faster, but can result in more compilations when something changes.</p>

</dd>
<dt id="How-do-I-access-functions-tasks-in-C">How do I access functions/tasks in C?</dt>
<dd>

<p>Use the SystemVerilog Direct Programming Interface. You write a Verilog function or task with input/outputs that match what you want to call in with C. Then mark that function as an external function. See the DPI chapter in the manual.</p>

</dd>
<dt id="How-do-I-access-signals-in-C">How do I access signals in C?</dt>
<dd>

<p>The best thing is to make a SystemVerilog &quot;export DPI task&quot; or function that accesses that signal, as described in the DPI chapter in the manual and DPI tutorials on the web. This will allow Verilator to better optimize the model and should be portable across simulators.</p>

<p>If you really want raw access to the signals, declare the signals you will be accessing with a /*verilator public*/ comment before the closing semicolon. Then scope into the C++ class to read the value of the signal, as you would any other member variable.</p>

<p>Signals are the smallest of 8-bit chars, 16-bit shorts, 32-bit longs, or 64-bit long longs that fits the width of the signal. Generally, you can use just uint32_t&#39;s for 1 to 32 bits, or vluint64_t for 1 to 64 bits, and the compiler will properly up-convert smaller entities.</p>

<p>Signals wider than 64 bits are stored as an array of 32-bit uint32_t&#39;s. Thus to read bits 31:0, access signal[0], and for bits 63:32, access signal[1]. Unused bits (for example bit numbers 65-96 of a 65-bit vector) will always be zero. if you change the value you must make sure to pack zeros in the unused bits or core-dumps may result. (Because Verilator strips array bound checks where it believes them to be unnecessary.)</p>

<p>In the SYSTEMC example above, if you had in our.v:</p>

<pre><code>    input clk /*verilator public*/;
    // Note the placement of the semicolon above</code></pre>

<p>From the sc_main.cpp file, you&#39;d then:</p>

<pre><code>    #include &quot;Vour.h&quot;
    #include &quot;Vour_our.h&quot;
    cout &lt;&lt; &quot;clock is &quot; &lt;&lt; top-&gt;our-&gt;clk &lt;&lt; endl;</code></pre>

<p>In this example, clk is a bool you can read or set as any other variable. The value of normal signals may be set, though clocks shouldn&#39;t be changed by your code or you&#39;ll get strange results.</p>

</dd>
<dt id="Should-a-module-be-in-Verilog-or-SystemC">Should a module be in Verilog or SystemC?</dt>
<dd>

<p>Sometimes there is a block that just interconnects cells, and have a choice as to if you write it in Verilog or SystemC. Everything else being equal, best performance is when Verilator sees all of the design. So, look at the hierarchy of your design, labeling cells as to if they are SystemC or Verilog. Then:</p>

<p>A module with only SystemC cells below must be SystemC.</p>

<p>A module with a mix of Verilog and SystemC cells below must be SystemC. (As Verilator cannot connect to lower-level SystemC cells.)</p>

<p>A module with only Verilog cells below can be either, but for best performance should be Verilog. (The exception is if you have a design that is instantiated many times; in this case Verilating one of the lower modules and instantiating that Verilated cells multiple times into a SystemC module *may* be faster.)</p>

</dd>
</dl>

<h1 id="BUGS">BUGS</h1>

<p>First, check the the coding limitations section.</p>

<p>Next, try the --debug switch. This will enable additional internal assertions, and may help identify the problem.</p>

<p>Finally, reduce your code to the smallest possible routine that exhibits the bug. Even better, create a test in the test_regress/t directory, as follows:</p>

<pre><code>    cd test_regress
    cp -p t/t_EXAMPLE.pl t/t_BUG.pl
    cp -p t/t_EXAMPLE.v t/t_BUG.v</code></pre>

<p>There are many hits on how to write a good test in the driver.pl documentation which can be seen by running:</p>

<pre><code>    cd $VERILATOR_ROOT  # Need the original distribution kit
    test_regress/driver.pl --help</code></pre>

<p>Edit t/t_BUG.pl to suit your example; you can do anything you want in the Verilog code there; just make sure it retains the single clk input and no outputs. Now, the following should fail:</p>

<pre><code>    cd $VERILATOR_ROOT  # Need the original distribution kit
    cd test_regress
    t/t_BUG.pl  # Run on Verilator
    t/t_BUG.pl --debug # Run on Verilator, passing --debug to Verilator
    t/t_BUG.pl --vcs  # Run on a commercial simulator
    t/t_BUG.pl --nc|--iv|--ghdl  # Likewise on other simulators</code></pre>

<p>The test driver accepts a number of options, many of which mirror the main Verilator option. For example the previous test could have been run with debugging enabled. The full set of test options can be seen by running driver.pl --help as shown above.</p>

<p>Finally, report the bug using the bug tracker at <a href="http://www.veripool.org/verilator">http://www.veripool.org/verilator</a>. The bug will become publicly visible; if this is unacceptable, mail the bug report to <code>wsnyder@wsnyder.org</code>.</p>

<h1 id="HISTORY">HISTORY</h1>

<p>Verilator was conceived in 1994 by Paul Wasson at the Core Logic Group at Digital Equipment Corporation. The Verilog code that was converted to C was then merged with a C based CPU model of the Alpha processor and simulated in a C based environment called CCLI.</p>

<p>In 1995 Verilator started being used also for Multimedia and Network Processor development inside Digital. Duane Galbi took over active development of Verilator, and added several performance enhancements. CCLI was still being used as the shell.</p>

<p>In 1998, through the efforts of existing DECies, mainly Duane Galbi, Digital graciously agreed to release the source code. (Subject to the code not being resold, which is compatible with the GNU Public License.)</p>

<p>In 2001, Wilson Snyder took the kit, and added a SystemC mode, and called it Verilator2. This was the first packaged public release.</p>

<p>In 2002, Wilson Snyder created Verilator 3.000 by rewriting Verilator from scratch in C++. This added many optimizations, yielding about a 2-5x performance gain.</p>

<p>In 2009, major SystemVerilog and DPI language support was added.</p>

<p>In 2018, Verilator 4.000 was released with multithreaded support.</p>

<p>Currently, various language features and performance enhancements are added as the need arises. Verilator is now about 3x faster than in 2002, and is faster than many popular commercial simulators.</p>

<h1 id="AUTHORS">AUTHORS</h1>

<p>When possible, please instead report bugs to <a href="http://www.veripool.org/">http://www.veripool.org/</a>.</p>

<p>Wilson Snyder &lt;wsnyder@wsnyder.org&gt;</p>

<p>Major concepts by Paul Wasson, Duane Galbi, John Coiner and Jie Xu.</p>

<h1 id="CONTRIBUTORS">CONTRIBUTORS</h1>

<p>Many people have provided ideas and other assistance with Verilator.</p>

<p>The major corporate sponsors of Verilator, by providing significant contributions of time or funds include include Atmel Corporation, Cavium Inc., Compaq Corporation, Digital Equipment Corporation, Embecosm Ltd., Hicamp Systems, Intel Corporation, Mindspeed Technologies Inc., MicroTune Inc., picoChip Designs Ltd., Sun Microsystems Inc., Nauticus Networks Inc., and SiCortex Inc.</p>

<p>The people who have contributed major functionality are Byron Bradley, Jeremy Bennett, Jie Xu, Lane Brooks, John Coiner, Duane Galbi, Paul Wasson, and Wilson Snyder. Major testers included Jeff Dutton, Jonathon Donaldson, Ralf Karge, David Hewson, Iztok Jeras, Wim Michiels, Alex Solomatnikov, Sebastien Van Cauwenberghe, Gene Weber, and Clifford Wolf.</p>

<p>Some of the people who have provided ideas and feedback for Verilator include: Ahmed El-Mahmoudy, David Addison, Tariq B. Ahmad, Nikana Anastasiadis, Hans Van Antwerpen, Vasu Arasanipalai, Jens Arm, Sharad Bagri, Andrew Bardsley, Matthew Barr, Geoff Barrett, Julius Baxter, Jeremy Bennett, Michael Berman, Victor Besyakov, David Binderman, Johan Bjork, David Black, Tymoteusz Blazejczyk, Daniel Bone, Gregg Bouchard, Christopher Boumenot, Nick Bowler, Byron Bradley, Bryan Brady, Charlie Brej, J Briquet, Lane Brooks, John Brownlee, Jeff Bush, Lawrence Butcher, Ted Campbell, Chris Candler, Lauren Carlson, Donal Casey, Sebastien Van Cauwenberghe, Terry Chen, Enzo Chi, Robert A. Clark, Allan Cochrane, John Coiner, Laurens van Dam, Gunter Dannoritzer, Ashutosh Das, Bernard Deadman, John Demme, Mike Denio, John Deroo, Philip Derrick, Joe DErrico, John Dickol, Ruben Diez, Danny Ding, Ivan Djordjevic, Jonathon Donaldson, Sebastian Dressler, Alex Duller, Jeff Dutton, Usuario Eda, Chandan Egbert, Joe Eiler, Ahmed El-Mahmoudy, Trevor Elbourne, Robert Farrell, Eugen Fekete, Fabrizio Ferrandi, Brian Flachs, Andrea Foletto, Bob Fredieu, Duane Galbi, Christian Gelinek, Glen Gibb, Shankar Giri, Dan Gisselquist, Sam Gladstone, Amir Gonnen, Chitlesh Goorah, Xuan Guo, Neil Hamilton, Jannis Harder, Junji Hashimoto, Thomas Hawkins, Robert Henry, David Hewson, Jamey Hicks, Joel Holdsworth, Hiroki Honda, Alex Hornung, David Horton, Jae Hossell, Alan Hunter, James Hutchinson, Jamie Iles, Ben Jackson, Shareef Jalloq, Krzysztof Jankowski, HyungKi Jeong, Iztok Jeras, James Johnson, Christophe Joly, Franck Jullien, James Jung, Mike Kagen, Arthur Kahlich, Kaalia Kahn, Guy-Armand Kamendje, Vasu Kandadi, Patricio Kaplan, Ralf Karge, Dan Katz, Sol Katzman, Jonathan Kimmitt, Olof Kindgren, Dan Kirkham, Sobhan Klnv, Gernot Koch, Soon Koh, Steve Kolecki, Brett Koonce, Wojciech Koszek, Varun Koyyalagunta, David Kravitz, Roland Kruse, Sergey Kvachonok, Ed Lander, Steve Lang, Stephane Laurent, Walter Lavino, Christian Leber, Igor Lesik, John Li, Eivind Liland, Yu Sheng Lin, Charlie Lind, Andrew Ling, Paul Liu, Derek Lockhart, Arthur Low, Stefan Ludwig, Dan Lussier, Fred Ma, Duraid Madina, Julien Margetts, Mark Marshall, Alfonso Martinez, Yves Mathieu, Patrick Maupin, Jason McMullan, Elliot Mednick, Wim Michiels, Miodrag Milanovic, Wai Sum Mong, Sean Moore, Dennis Muhlestein, John Murphy, Richard Myers, Dimitris Nalbantis, Bob Newgard, Cong Van Nguyen, Paul Nitza, Pete Nixon, Lisa Noack, Mark Nodine, Andreas Olofsson, James Pallister, Brad Parker, Maciej Piechotka, David Pierce, Dominic Plunkett, David Poole, Mike Popoloski, Rich Porter, Niranjan Prabhu, Usha Priyadharshini, Mark Jackson Pulver, Prateek Puri, Marshal Qiao, Chris Randall, Anton Rapp, Josh Redford, Odd Magne Reitan, Frederic Requin, Alberto Del Rio, Oleg Rodionov, Paul Rolfe, Arjen Roodselaar, Jan Egil Ruud, John Sanguinetti, Galen Seitz, Salman Sheikh, Mike Shinkarovsky, Rafael Shirakawa, Jeffrey Short, Rodney Sinclair, Steven Slatter, Brian Small, Wilson Snyder, Alex Solomatnikov, Wei Song, Art Stamness, John Stevenson, Patrick Stewart, Rob Stoddard, Todd Strader, John Stroebel, Sven Stucki, Emerson Suguimoto, Gene Sullivan, Renga Sundararajan, Yutetsu Takatsukasa, Peter Tengstrand, Wesley Terpstra, Rui Terra, Stefan Thiede, Gary Thomas, Kevin Thompson, Ian Thompson, Mike Thyer, Hans Tichelaar, Steve Tong, Michael Tresidder, Holger Waechtler, Stefan Wallentowitz, Shawn Wang, Paul Wasson, Greg Waters, Thomas Watts, Eugene Weber, David Welch, Thomas J Whatson, Leon Wildman, Gerald Williams, Trevor Williams, Jeff Winston, Joshua Wise, Clifford Wolf, Johan Wouters, Junyi Xi, Ding Xiaoliang, Jie Xu, Mandy Xu, Luke Yang, and Amir Yazdanbakhsh.</p>

<p>Thanks to them, and all those we&#39;ve missed including above, or wished to remain anonymous.</p>

<h1 id="DISTRIBUTION">DISTRIBUTION</h1>

<p>The latest version is available from <a href="http://www.veripool.org/">http://www.veripool.org/</a>.</p>

<p>Copyright 2003-2019 by Wilson Snyder. Verilator is free software; you can redistribute it and/or modify the Verilator internals under the terms of either the GNU Lesser General Public License Version 3 or the Perl Artistic License Version 2.0.</p>

<h1 id="SEE-ALSO">SEE ALSO</h1>

<p><a>verilator_coverage</a>, <a>verilator_gantt</a>, <a>verilator_profcfunc</a>, <a>make</a>,</p>

<p><a href="#verilator---help">&quot;verilator --help&quot;</a> which is the source for this document,</p>

<p>and internals.txt in the distribution.</p>


</body>

</html>


